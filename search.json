[{"path":"https://robinhankin.github.io/clifford/CODE_OF_CONDUCT.html","id":null,"dir":"","previous_headings":"","what":"Contributor covenant code of conduct","title":"Contributor covenant code of conduct","text":"members, contributors, leaders wish make participation community pleasant productive experience everyone. try act interact ways contribute open, welcoming, inclusive, healthy community. assume good faith, per WP:AGF. Examples behaviour contributes positive environment community include: Demonstrating empathy kindness toward people Communicating respectfully differing opinions, viewpoints, experiences Giving gracefully accepting constructive feedback Accepting responsibility apologizing affected mistakes, learning experience Focusing best just us individuals, overall community","code":""},{"path":"https://robinhankin.github.io/clifford/CONTRIBUTING.html","id":null,"dir":"","previous_headings":"","what":"Contributing to clifford","title":"Contributing to clifford","text":"Thank considering contributing clifford! appreciate interest making project better. Please read adhere Code Conduct maintain safe, welcoming, inclusive environment. Various forms contributions welcome: Bug Reports: feel free report bugs encounter. Use cases: use clifford, tell ! want know software used! Documentation: typos, clarity issues, missing guides: help welcome . Feature discussions/requests: got idea? Open issue discuss potential. Code contributions: code contributions welcome.","code":""},{"path":"https://robinhankin.github.io/clifford/articles/complex_clifford.html","id":"first-method","dir":"Articles","previous_headings":"","what":"First method","title":"Complex arithmetic using Clifford algebra","text":"use \\(\\operatorname{Cl}(0,1)\\), \\(e_1^2=-1\\). Package idiom straightforward; coerce complex numbers Clifford objects vice versa, need couple functions: numerical verification immediate. First choose complex numbers: , example: Checking coercion homomorphism easy: , note * left geometric product, * right usual complex multiplication. map invertible can check way :","code":"signature(0,1) options(maxdim=1) # paranoid-level safety measure complex_to_clifford <- function(z){Re(z) + e(1)*Im(z)} clifford_to_complex <- function(C){const(C) + 1i*getcoeffs(C,1)} clifford_to_complex <- function(C){const(C) + 1i*coeffs(Im(C))} z1 <- 35 + 67i z2 <- -2 + 12i z1 ## [1] 35+67i complex_to_clifford(z1) ## Element of a Clifford algebra, equal to ## + 35 + 67e_1 complex_to_clifford(z1) * complex_to_clifford(z2) == complex_to_clifford(z1*z2) ## [1] TRUE (C1 <- 23 + 7*e(1)) ## Element of a Clifford algebra, equal to ## + 23 + 7e_1 clifford_to_complex(C1) ## [1] 23+7i C2 <- 2  - 8*e(1) clifford_to_complex(C1)*clifford_to_complex(C2) == clifford_to_complex(C1*C2) ## [1] TRUE"},{"path":"https://robinhankin.github.io/clifford/articles/complex_clifford.html","id":"second-method","dir":"Articles","previous_headings":"","what":"Second method","title":"Complex arithmetic using Clifford algebra","text":"use \\(\\operatorname{Cl}(2)\\), \\(e_1^2=e_2^2=1\\), identify imaginary unit \\(\\) \\(e_{12}\\) (thus \\(e_{12}^2=e_{12}e_{12}=e_{1212}=-e_{1122}=-e_1^2e_2^2=-1\\)). general complex number \\(z=x+iy\\) maps Clifford object \\(x + ye_{12}\\). numerical verification:","code":"options(maxdim=2)  # paranoid-level safety measure signature(2) complex_to_clifford <- function(z){Re(z) + e(1:2)*Im(z)} clifford_to_complex <- function(C){const(C) + 1i*coeffs(Im(C))} z1 <- 35 + 67i z2 <- -2 + 12i complex_to_clifford(z1) * complex_to_clifford(z2) == complex_to_clifford(z1*z2) ## [1] TRUE C1 <- 23 + 7*e(1:2) C2 <- 2  - 8*e(1:2) clifford_to_complex(C1)*clifford_to_complex(C2) == clifford_to_complex(C1*C2) ## [1] TRUE"},{"path":"https://robinhankin.github.io/clifford/articles/complex_clifford.html","id":"note","dir":"Articles","previous_headings":"Second method","what":"Note","title":"Complex arithmetic using Clifford algebra","text":"identification \\(x+iy\\longrightarrow x+ye_{12}\\) homomorphism whenever \\(e_1^2e_2^2=1\\); used \\(\\operatorname{Cl}(2,0)\\) \\(e_1^2=e_2^2=1\\). However, relation also satisfied \\(e_1^2=e_2^2=-1\\), can equally well use \\(\\operatorname{Cl}(0,2)\\):","code":"signature(0,2) c( complex_to_clifford(z1)*complex_to_clifford(z2) == complex_to_clifford(z1*z2), clifford_to_complex(C1)*clifford_to_complex(C2) == clifford_to_complex(C1*C2) ) ## [1] TRUE TRUE"},{"path":"https://robinhankin.github.io/clifford/articles/complex_clifford.html","id":"default","dir":"Articles","previous_headings":"Second method","what":"Default","title":"Complex arithmetic using Clifford algebra","text":"best return signature maxdim default values order prevent interference vignettes:","code":"options(maxdim=NULL) signature(Inf)"},{"path":[]},{"path":"https://robinhankin.github.io/clifford/articles/conformal_algebra_clifford.html","id":"points","dir":"Articles","previous_headings":"","what":"Points","title":"Conformal geometry with Clifford algebra","text":"definitions, can consider Euclidean vectors \\(\\mathbf{},\\mathbf{b}\\\\mathbb{R}^3\\) conformal embeddings \\(\\mathbf{},\\mathbf{B}\\) given \\[ \\mathbf{}=C(\\mathbf{})=\\mathbf{}+\\mathbf{}^2\\mathbf{e}_\\infty/2 +\\mathbf{e}_0\\qquad\\mathbf{B}=C(\\mathbf{b})=\\mathbf{b}+\\mathbf{b}^2\\mathbf{e}_\\infty/2 +\\mathbf{e}_0 \\] straightforward package idiom: Thus point() takes R vector length 3 returns conformal embedding. example, may translate points \\((1,2,5)\\) \\((2,2,2)\\) conformal equivalent: can shown \\(\\mathbf{}\\cdot\\mathbf{B}=-\\left\\lVert\\mathbf{}-\\mathbf{b}\\right\\rVert^2/2\\) [dot product Clifford inner product, %.%]. Package idiom verify showing two results match.","code":"point <- function(x){ as.1vector(x) + sum(x^2)*einf/2 + e0 } a <- c(1,2,5) b <- c(2,2,2) point(a) ## Element of a Clifford algebra, equal to ## + 1e_1 + 2e_2 + 5e_3 + 14.5e_4 + 15.5e_5 point(b) ## Element of a Clifford algebra, equal to ## + 2e_1 + 2e_2 + 2e_3 + 5.5e_4 + 6.5e_5 c(conformal=drop(point(a) %.% point(b)), Euclidean = -sum((a-b)^2)/2) ## conformal Euclidean  ##        -5        -5"},{"path":"https://robinhankin.github.io/clifford/articles/conformal_algebra_clifford.html","id":"sphere-ipns","dir":"Articles","previous_headings":"Points","what":"Sphere, IPNS","title":"Conformal geometry with Clifford algebra","text":"can define sphere center \\(\\mathbf{}\\) radius \\(\\rho\\) \\[ \\mathbf{S}=C(\\mathbf{}) - \\rho^2\\mathbf{e}_\\infty/2 \\] sphere just inner product null space \\(\\mathbf{S}\\), \\(\\left\\lbrace\\mathbf{x}\\colon\\mathbf{S}\\cdot\\mathbf{x}=0\\right\\rbrace\\). straightforward implement computationally. Suppose sphere radius 5, center \\((1,2,3)\\): object S conformal representation sphere. radius \\(\\rho\\) can calculated \\(\\mathbf{S}^2=\\rho^2\\). Package idiom: Finding center sphere slightly involved; Hildenbrand calls sandwich product given \\(P=\\mathbf{S}\\mathbf{e}_\\infty\\mathbf{S}\\): Hildenbrand shows scaling factor \\(-2\\) gives us recognise point \\((1,2,3)\\):","code":"sphere <- function(x,r){ point(x) - r^2*einf/2} S <- sphere(1:3,5)  # center (1,2,3) radius 5: S ## Element of a Clifford algebra, equal to ## + 1e_1 + 2e_2 + 3e_3 - 6e_4 - 5e_5 drop(S^2)   # 5^2 = 25 ## [1] 25 S*einf*S ## Element of a Clifford algebra, equal to ## - 2e_1 - 4e_2 - 6e_3 - 13e_4 - 15e_5 -S*einf*S/2 ## Element of a Clifford algebra, equal to ## + 1e_1 + 2e_2 + 3e_3 + 6.5e_4 + 7.5e_5 point(1:3) ## Element of a Clifford algebra, equal to ## + 1e_1 + 2e_2 + 3e_3 + 6.5e_4 + 7.5e_5"},{"path":"https://robinhankin.github.io/clifford/articles/conformal_algebra_clifford.html","id":"sphere-opns","dir":"Articles","previous_headings":"Points","what":"Sphere, OPNS","title":"Conformal geometry with Clifford algebra","text":"can also consider OPNS sphere, defined terms four points lie . example, four points \\((0,0,0)\\), \\((1,0,0)\\), \\((0,1,0)\\), \\((0,0,1)\\) rather involved algebraic calculation resulting sphere radius \\(\\frac{\\sqrt{3}}{2}\\) center \\(\\left(\\frac{1}{2},\\frac{1}{2},\\frac{1}{2}\\right)\\). conformal representation sphere OPNS \\[ S^*=P_1\\wedge P_2\\wedge P_3\\wedge P_4 \\] points lie sphere set \\[\\left\\lbrace\\mathbf{x}\\colon\\mathbf{x}\\wedge S^*=0\\right\\rbrace.\\] Observe parameterization require one take basis \\(\\mathbb{R}^3\\), results presented terms vector quantities: point one need consider components elements vector. R idiom defining sphere touching \\(\\left\\lbrace P_1,P_2,P_3,P_4\\right\\rbrace\\) straightforward: representation sphere (translating center radius yet implemented). Slightly slicker R idiom might : verification, may check point \\(\\left(\\frac{1}{2},\\frac{1}{2},\\frac{1}{2}+\\frac{\\sqrt{3}}{2}\\right)\\) sphere well: see \\(p\\wedge S\\) zero within numerical error. observe established without taking basis \\(\\mathbb{R}^3\\).","code":"origin <- point(c(0,0,0)) px <- point(c(1,0,0)) py <- point(c(0,1,0)) pz <- point(c(0,0,1))  (S <- origin ^ px ^ py ^ pz) ## Element of a Clifford algebra, equal to ## + 0.5e_1234 - 0.5e_1235 - 0.5e_1245 + 0.5e_1345 - 0.5e_2345 spherestar <- function(...){Reduce(`^`,list(...))} spherestar(origin, px, py, pz) ## Element of a Clifford algebra, equal to ## + 0.5e_1234 - 0.5e_1235 - 0.5e_1245 + 0.5e_1345 - 0.5e_2345 p <- point(c(1,1,1+sqrt(3))/2) Mod(p ^ S) ## [1] 1.110223e-16"},{"path":"https://robinhankin.github.io/clifford/articles/conformal_algebra_clifford.html","id":"planes","dir":"Articles","previous_headings":"","what":"Planes","title":"Conformal geometry with Clifford algebra","text":"plane defined \\(\\hat{\\mathbf{n}} + d\\mathbf{e}_\\infty\\), \\(\\hat{\\mathbf{n}}\\) unit normal \\(d\\) distance origin. example, consider plane \\(\\Pi\\) normal \\(\\mathbf{n}=\\left(1,2,5\\right)\\) distance 7. may use plane() first need calculate \\(\\hat{\\mathbf{n}}=\\mathbf{n}/\\left|\\mathbf{n}\\right|\\): Just check, may verify points known lie \\(\\Pi\\) fact IPNS. observe point \\(7\\hat{\\mathbf{n}}\\\\Pi\\), also vectors \\(\\mathbf{u}=(2,-1,0)\\) \\(\\mathbf{v}=(5,0,-1)\\) orthogonal normal \\(\\Pi\\). \\(7\\hat{\\mathbf{n}} + \\alpha\\mathbf{u} + \\beta\\mathbf{v}\\\\Pi\\) real numbers \\(\\alpha,\\beta\\). R: use made-values \\(\\alpha,\\beta\\) generate P1, P2, P3 known lie plane \\(\\Pi\\). verify points lie IPNS \\(\\Pi\\) need take inner product conformal representation \\(\\Pi\\): see zero (numerical precision), showing indeed \\(7\\hat{\\mathbf{n}} + \\alpha\\mathbf{u} + \\beta\\mathbf{v}\\\\operatorname{IPNS}(\\Pi)\\) least values \\(\\alpha\\) \\(\\beta\\). Alternatively, plane can thought sphere touches point infinity; thus OPNS plane given \\[ \\pi^\\star = P_1\\wedge P_2\\wedge P_3\\wedge\\mathbf{e}_\\infty \\] \\(P_1,P_2,P_3\\) points lie plane. illustrate use three points used IPNS : verification can create another point known plane check OPNS. use p4 \\(d\\hat{\\mathbf{n}} + 7.6\\mathbf{u} - 9.23\\mathbf{v}\\): see small result showing p4 indeed OPNS plane Pi2.","code":"plane <- function(n,d){ as.1vector(n/sqrt(sum(n^2))) + d*einf} n <- c(1,2,5) nhat <- n/sqrt(sum(n^2)) d <- 7 Pi <- plane(nhat,d) Pi ## Element of a Clifford algebra, equal to ## + 0.1825742e_1 + 0.3651484e_2 + 0.9128709e_3 + 7e_4 + 7e_5 u <- c(2,-1,0) v <- c(5,0,-1) P1 <- point(d*nhat)                 P2 <- point(d*nhat + 1.3*u + 3.44*v) P3 <- point(d*nhat - 6.1*u + 1.02*v) c(drop(Pi %.% P1),drop(Pi %.% P2),drop(Pi %.% P3)) ## [1]  3.191891e-16 -1.110223e-16 -3.330669e-16 Pi2 <- P1 ^ P2 ^ P3 ^ einf p4 <- point(d*nhat + 7.6*u - 9.23*v) Mod(Pi2 ^ p4) ## [1] 3.005929e-13"},{"path":"https://robinhankin.github.io/clifford/articles/conformal_algebra_clifford.html","id":"circle","dir":"Articles","previous_headings":"","what":"Circle","title":"Conformal geometry with Clifford algebra","text":"circle defined intersection two spheres: example circle may represented OPNS specifying three points lie : \\[ Z^*=P_1\\wedge P_2\\wedge P_3\\] verify: see poc least close circle small magnitude terms wedge product.","code":"circle <- function(S1,S2){  # IPNS     S1 ^ S2 } circle(sphere(1:3,5),sphere(c(1.1,2.1,3.4),6)) ## Element of a Clifford algebra, equal to ## - 0.1e_12 + 0.1e_13 + 0.5e_23 - 3.31e_14 - 7.22e_24 - 9.33e_34 - 3.41e_15 - ## 7.32e_25 - 9.73e_35 + 3.91e_45 circlestar <- function(...){  # OPNS; A^B^C     jj <- list(...)     stopifnot(length(jj) == dimension)     Reduce(`^`,lapply(jj,point)) }  (CIRC <- circlestar(c(1,2,3),c(5,6,3),c(8,8,-2))) ## Element of a Clifford algebra, equal to ## + 8e_123 - 38e_124 - 110e_134 - 54e_234 - 42e_125 - 130e_135 - 74e_235 + ## 40e_145 + 68e_245 + 140e_345 poc  # point on circle, found numerically [chunk omitted] ## Element of a Clifford algebra, equal to ## - 0.7152127e_1 - 0.2498563e_2 + 0.3267822e_3 - 0.159628e_4 + 0.840372e_5 poc ^ CIRC ## Element of a Clifford algebra, equal to ## - 0.003402925e_1234 - 0.003402866e_1235 - 0.001701745e_1245 - 0.00850813e_1345 ## - 0.008507714e_2345"},{"path":"https://robinhankin.github.io/clifford/articles/conformal_algebra_clifford.html","id":"lines-and-point-pairs","dir":"Articles","previous_headings":"","what":"Lines and point pairs","title":"Conformal geometry with Clifford algebra","text":"line intersection two planes; R: “point pair” intersection three spheres; R: obvious three spheres intersect pair points; still less obvious process associative. However, may verify associativity explicitly:","code":"line <- function(P1,P2){ P1 ^ P2 } pointpair <- function(S1,S2,S3){ S1 ^ S2 ^ S3 } S1 <- sphere(c(3,2,4),3) S2 <- sphere(c(3,1,4),4) S3 <- sphere(c(1,3,3),3) (S1^S2)^S3 ## Element of a Clifford algebra, equal to ## - 5e_123 + 31e_124 + 25e_134 - 40.5e_234 + 29e_125 + 25e_135 - 39.5e_235 - ## 10e_145 + 10e_245 - 5e_345 (S1^S2)^S3 == S1^(S2^S3) ## [1] TRUE"},{"path":[]},{"path":"https://robinhankin.github.io/clifford/articles/cramer_clifford.html","id":"using-clifford-algebra","dir":"Articles","previous_headings":"","what":"Using Clifford algebra","title":"Cramer's rule in civilised form with Clifford algebra","text":"Considering \\(\\mathbb{R}^3\\) vector space given vectors \\({\\mathbf }, {\\mathbf b}, {\\mathbf c}\\) spanning space can express vector \\({\\mathbf x}\\\\mathbb{R}^3\\) \\[\\mathbf{x}= \\left(\\frac{{\\mathbf x}\\wedge{\\mathbf b}\\wedge{\\mathbf c}}{{\\mathbf }\\wedge{\\mathbf b}\\wedge{\\mathbf c}}\\right){\\mathbf }+ \\left(\\frac{{\\mathbf }\\wedge{\\mathbf x}\\wedge{\\mathbf c}}{{\\mathbf }\\wedge{\\mathbf b}\\wedge{\\mathbf c}}\\right){\\mathbf b}+ \\left(\\frac{{\\mathbf }\\wedge{\\mathbf b}\\wedge{\\mathbf x}}{{\\mathbf }\\wedge{\\mathbf b}\\wedge{\\mathbf c}}\\right){\\mathbf c} \\] Cramer’s rule expressed directly vector form (rather components). Observe numerator denominator bracketed term pseudoscalar; ratio two pseudoscalars ordinary scalar. Package idiom straightforward: Thus expressed \\({\\mathbf x}\\) (except possible roundoff error) linear combination \\({\\mathbf },{\\mathbf b},{\\mathbf c}\\), specifically \\({\\mathbf x}=\\alpha{\\mathbf }+\\beta{\\mathbf b}+\\gamma{\\mathbf c}\\). Conversely, might know coefficients try determine using package idiom. use \\(1,2,3\\) suppose \\({\\mathbf y}=1{\\mathbf }+2{\\mathbf b}+3{\\mathbf c}\\):","code":"a <- as.1vector(runif(3)) b <- as.1vector(runif(3)) c <- as.1vector(runif(3))  (x <- as.1vector(1:3)) ## Element of a Clifford algebra, equal to ## + 1e_1 + 2e_2 + 3e_3 options(maxdim = 3)  # needed to drop() pseudoscalars abc <- drop(a ^ b ^ c)  alpha <- drop(x ^ b ^ c)/abc beta  <- drop(a ^ x ^ c)/abc gamma <- drop(a ^ b ^ x)/abc  c(alpha,beta,gamma) ## [1] -3.805997 -5.328439  8.309581 alpha*a + beta*b + gamma*c ## Element of a Clifford algebra, equal to ## + 1e_1 + 2e_2 + 3e_3 Mod(alpha*a + beta*b + gamma*c-x) ## [1] 0 y <- a*1 + b*2 + c*3 c(     drop(y ^ b ^ c)/abc,     drop(a ^ y ^ c)/abc,     drop(a ^ b ^ y)/abc ) ## [1] 1 2 3"},{"path":"https://robinhankin.github.io/clifford/articles/cramer_clifford.html","id":"higher-dimensional-space","dir":"Articles","previous_headings":"","what":"Higher dimensional space","title":"Cramer's rule in civilised form with Clifford algebra","text":"accomplish arbitrary-dimensional space straightforward. consider \\(\\mathbb{R}^{5}\\): coefficients given : can reconstitute vector \\(x\\): , somewhat slicker: Conversely, know coefficients , say, 15:11, find coefficients: see original coefficients recovered, numerical accuracy.","code":"n <- 5                                                 # dimensionality of space options(maxdim=5)                                      # safety precaution x <- as.1vector(seq_len(n))                            # target vector x ## Element of a Clifford algebra, equal to ## + 1e_1 + 2e_2 + 3e_3 + 4e_4 + 5e_5 L <- replicate(n,as.1vector(rnorm(n)),simplify=FALSE)  # spanning vectors subst <- function(L,n,x){L[[n]] <- x; return(L)}       # list substitution coeff <- function(n,L,x){       drop(Reduce(`^`,subst(L,n,x))/Reduce(`^`,L)) } (alpha <- sapply(seq_len(n),coeff,L,x)) ## [1]  21.610237  27.030973  11.866383 -22.222116   3.199427 out <- as.clifford(0) f <- function(i){alpha[i]*L[[i]]} for(i in seq_len(n)){       out <- out + f(i) } Mod(out-x)  # zero to numerical precision ## [1] 2.340649e-14 Reduce(`+`,sapply(seq_len(n),f,simplify=FALSE)) ## Element of a Clifford algebra, equal to ## + 1e_1 + 2e_2 + 3e_3 + 4e_4 + 5e_5 coeffs <- 15:11 x <- 0 for(i in seq_len(5)){x <- x + coeffs[i]*L[[i]]} x ## Element of a Clifford algebra, equal to ## + 29.23618e_1 + 18.68409e_2 + 20.23065e_3 - 0.6361232e_4 - 40.82507e_5 sapply(seq_len(n),coeff,L,x) ## [1] 15 14 13 12 11"},{"path":[]},{"path":[]},{"path":[]},{"path":[]},{"path":"https://robinhankin.github.io/clifford/articles/lorentz_clifford.html","id":"lorentz-transforms-in-terms-of-rapidity","dir":"Articles","previous_headings":"","what":"Lorentz transforms in terms of rapidity","title":"Lorentz transforms via Clifford algebra","text":"general form Lorentz transform speed \\(u\\) \\(x\\)-direction \\[ \\begin{pmatrix} \\overline{t}\\\\ \\overline{x} \\end{pmatrix} = \\begin{pmatrix} \\gamma&-\\gamma v\\\\ -\\gamma v&\\gamma \\end{pmatrix} \\begin{pmatrix} t\\\\x\\end{pmatrix} \\] \\(\\gamma=(1-u^2)^{-1/2}\\). Writing \\(\\cosh\\phi=\\gamma\\) noting \\(\\phi\\) real (sometimes \\(\\phi\\) known rapidity) get \\[ \\begin{pmatrix} \\cosh\\phi&-\\sinh\\phi\\\\ -\\sinh\\phi &\\cosh\\phi \\end{pmatrix} \\] transformation, can see matrix unit determinant.","code":""},{"path":"https://robinhankin.github.io/clifford/articles/lorentz_clifford.html","id":"lorentz-transforms-in-clifford-algebra","dir":"Articles","previous_headings":"","what":"Lorentz transforms in Clifford algebra","title":"Lorentz transforms via Clifford algebra","text":"considered four-vector \\(s=(1,5,3,2)\\). Clifford formalism appears Algebraically \\(1\\mathbf{e}_1+5\\mathbf{e}_2+3\\mathbf{e}_3+2\\mathbf{e}_4\\) (Snygg write \\(1\\mathbf{e}_0+5\\mathbf{e}_1+3\\mathbf{e}_2+2\\mathbf{e}_3\\); use notation basis vectors numbered 1 package, zero). Also note vectors appear implementation-specific order, per disordR discipline (R. K. S. Hankin 2022b). metric \\[ \\begin{pmatrix} 1&0&0&0\\\\ 0&-1&0&0\\\\ 0&0&-1&0\\\\ 0&0&0&-1 \\end{pmatrix} \\] [NB relativity, word “signature” refers eigenvalues metric, signature matrix \\((1,3)\\) [sometimes \\({+}{-}{-}{-}\\)], one positive three negative eigenvalues. package idiom, “signature” means number basis vectors square \\(+1\\) \\(-1\\), implement metric using signature \\((1,3)\\)]. squared interval four-vector given might use slightly slicker efficient idiom quad.form() quadform package: Clifford equivalent scalprod() [remembering set signature 1]: seek boost \\(B\\{\\mathcal C}_{1,3}\\) \\(\\overline{s}=B^{-1}sB\\) (juxtaposition indicating geometric product). start boost \\(x\\)-direction rapidity \\(\\phi\\). \\(B=\\cosh(\\phi/2)+{\\mathbf e}_{12}\\sinh(\\phi/2)\\). note \\(B^{-1}=\\cosh(\\phi/2)-{\\mathbf e}_{12}\\sinh(\\phi/2)\\). Numerically: may verify rapidities add: may formally write \\(B=\\exp({\\mathbf e}_{12}\\phi/2)\\) grounds \\[ \\begin{eqnarray} \\exp({\\mathbf e}_{12}x) &=&1+\\mathbf{e}_{12}x + \\frac{(\\mathbf{e}_{12}x)^2}{2!} + \\frac{(\\mathbf{e}_{12}x)^3}{3!}+\\frac{(\\mathbf{e}_{12}x)^4}{4!}+\\cdots\\\\ &=& (1+x^2/2+x^4/4!+\\cdots) + \\mathbf{e}_{12}(x+\\frac{x^3}{3!}+\\cdots)\\\\ &=& \\cosh x + \\mathbf{e}_{12}\\sinh x \\end{eqnarray} \\] note exponential obeys usual rules regular exponential function \\(e^x,x\\\\mathbb{R}\\). generally, transform rapidity \\(\\phi\\) direction cosines \\(k_x,k_y,k_z\\) transform \\[ B_{xyz}= \\cosh(\\phi/2) +k_x\\mathbf{e}_{12}\\sinh(\\phi/2) +k_y\\mathbf{e}_{13}\\sinh(\\phi/2) +k_z\\mathbf{e}_{14}\\sinh(\\phi/2) \\] can use standard Clifford algebra (together fact \\(k_x^2+k_y^2+k_z^2=1\\)) demonstrate transformations. Numerically: two boosts different direction cosines, result complicated: , see new terms present pure boosts correspond rotation. Now consider general four-vector \\(s=s^1\\mathbf{e}_1+s^2\\mathbf{e}_2+s^3\\mathbf{e}_3+s^4\\mathbf{e}_4\\) calculate \\(B^{-1}sB\\). made easier use facts \\(\\mathbf{e}_{12}\\) commutes \\(\\mathbf{e}_3\\) \\(\\mathbf{e}_4\\) well scalars, anticommutes \\(\\mathbf{e}_1\\) \\(\\mathbf{e}_2\\). Noting \\(\\exp(\\mathbf{e}_{12})\\) linear combination scalar \\(\\mathbf{e}_{12}\\) \\[ \\begin{eqnarray} B^{-1}sB &=& \\exp(-\\mathbf{e}_{12}\\phi/2)(s^1\\mathbf{e}_1+s^2\\mathbf{e}_2+s^3\\mathbf{e}_3+s^4\\mathbf{e}_4)\\exp(\\mathbf{e}_{12}\\phi/2)\\\\ &=& (\\mathbf{e}_1s^1+\\mathbf{e}_2s^2)\\exp(\\mathbf{e}_{12}\\phi/2)\\exp(\\mathbf{e}_{12}\\phi/2)+\\mathbf{e}_3s^3 + \\mathbf{e}_4s^4\\\\ &=& \\mathbf{e}_1(s^1\\cosh\\phi-s^2\\sinh\\phi)+\\mathbf{e}_2(s^2\\cosh\\phi-s^1\\sinh\\phi) +\\mathbf{e}_3s^3+\\mathbf{e}_4s^4 \\end{eqnarray}\\] required (matches matrix version). two boosts \\(B_1\\) \\(B_2\\) combined boost either \\(B_1B_2\\) (\\(B_1\\) followed \\(B_2\\)) \\(B_2B_1\\) (\\(B_2\\) followed \\(B_1\\)). Numerical methods straightforward demonstrate .","code":"(scliff <- as.1vector(fourvec)) ## Element of a Clifford algebra, equal to ## + 1e_1 + 5e_2 + 3e_3 + 2e_4 M <- diag(c(1,-1,-1,-1)) t(fourvec) %*% M %*% fourvec ##      [,1] ## [1,]  -37 quad.form(M,fourvec) ##      [,1] ## [1,]  -37 signature(1,3) scalprod(scliff,scliff) ## [1] -37 phi <- 2.1234534   # just a made-up random value B <- cosh(phi/2) + sinh(phi/2)*e(1:2)  Binv <- rev(B) # cosh(phi/2)- sinh(phi/2)*e(1:2) B*Binv ## Element of a Clifford algebra, equal to ## scalar ( 1 ) B <- function(phi){cosh(phi/2) + sinh(phi/2)*e(1:2)} B(0.26) * B(1.33) ## Element of a Clifford algebra, equal to ## + 1.333011 + 0.8814299e_12 B(0.26 + 1.33) # should match ## Element of a Clifford algebra, equal to ## + 1.333011 + 0.8814299e_12 B3 <- function(phi,k){cosh(phi/2) + (      +k[1]*sinh(phi/2)*e(c(1,2))      +k[2]*sinh(phi/2)*e(c(1,3))      +k[3]*sinh(phi/2)*e(c(1,4))    )} k <- function(kx,ky){c(kx, ky, sqrt(1-kx^2-ky^2))} kx <- +0.23 ky <- -0.38   k1 <- k(kx=0.23, ky=-0.38) sum(k1^2) # verify; should be = 1 ## [1] 1 zap(B3(0.3,k1)*B3(1.9,k1))  # zap() kills terms with small coefficients ## Element of a Clifford algebra, equal to ## + 1.668519 + 0.3071989e_12 - 0.507546e_13 + 1.196654e_14 zap(B3(0.3+1.9,k1)) # should match previous line (up to numerical accuracy) ## Element of a Clifford algebra, equal to ## + 1.668519 + 0.3071989e_12 - 0.507546e_13 + 1.196654e_14 k2 <- k(-0.5,0.1) zap(B3(2.4,k1) * B3(1.9,k2)) ## Element of a Clifford algebra, equal to ## + 3.716216 - 0.479412e_12 - 0.653413e_13 + 0.277158e_23 + 3.722481e_14 - ## 1.071824e_24 + 0.691205e_34"},{"path":"https://robinhankin.github.io/clifford/articles/lorentz_clifford.html","id":"numerical-methods-lorentz-transforms-using-the-clifford-package","dir":"Articles","previous_headings":"","what":"Numerical methods: Lorentz transforms using the Clifford package","title":"Lorentz transforms via Clifford algebra","text":"considered boost Bmat, show effect boost terms Clifford objects, using specialist function f(): Thus can express Lorentz transform Clifford object: first thing verify inverse B behaves expected: can apply transformation \\(\\overline{s}=B^{-1}sB\\): Comparing result lorentz package see agreement within numerical precision. can verify squared interval unchanged: matching untransformed square interval.","code":"f <- function(u){     phi <- acosh(gam(u))               # rapidity     k <- cosines(u)                    # direction cosines     return(            cosh(phi/2)                 # t     + k[1]*sinh(phi/2)*basis(c(1,2))   # x     + k[2]*sinh(phi/2)*basis(c(1,3))   # y     + k[3]*sinh(phi/2)*basis(c(1,4))   # z     ) } u <- as.3vel(-c(0.2,0.3,0.4))  # negative (passive transform) options(digits=5) (B <- f(u)) ## Element of a Clifford algebra, equal to ## + 1.0457 - 0.1135e_12 - 0.17025e_13 - 0.22699e_14 B*rev(B) ## Element of a Clifford algebra, equal to ## scalar ( 1 ) zap(rev(B)*scliff*B) ## Element of a Clifford algebra, equal to ## - 2.0175e_1 + 5.1104e_2 + 3.1657e_3 + 2.2209e_4 Bmat %*% fourvec ##      [,1] ## t -2.0175 ## x  5.1104 ## y  3.1657 ## z  2.2209 jj <- rev(B)*scliff*B scalprod(jj,jj) ## [1] -37"},{"path":"https://robinhankin.github.io/clifford/articles/lorentz_clifford.html","id":"multiple-boosts","dir":"Articles","previous_headings":"","what":"Multiple boosts","title":"Lorentz transforms via Clifford algebra","text":"Successive Lorentz boosts can induce rotation well translation. , note Clifford object Buvw nonzero scalar component, also nonzero e_1234 component. However, represents consistent Lorentz transformation: can now apply transform four-velocity:","code":"u <- as.3vel(c(0.2, 0.3,  0.4)) v <- as.3vel(c(0.5, 0.0, -0.4)) w <- as.3vel(c(0.0, 0.7,  0.1)) Buvw <- f(u)*f(v)*f(w) zap(Buvw) ## Element of a Clifford algebra, equal to ## + 1.2914 + 0.45284e_12 + 0.69409e_13 - 0.14103e_23 + 0.07821e_14 + 0.07767e_24 ## + 0.02902e_34 - 0.04011e_1234 zap(Buvw*rev(Buvw)) ## [1] 1 n <- as.1vector(c(1,0,0,0)) zap(rev(Buvw) * n * Buvw) ## Element of a Clifford algebra, equal to ## + 2.3891e_1 + 0.98367e_2 + 1.9312e_3 + 0.10269e_4"},{"path":"https://robinhankin.github.io/clifford/articles/lorentz_clifford.html","id":"algebra-of-clifford-representations","dir":"Articles","previous_headings":"","what":"Algebra of Clifford representations","title":"Lorentz transforms via Clifford algebra","text":"can shed light representation Lorentz transforms follows: Thus can see, example, e12*e13 = -e23 e13*e12 = +e23.","code":"signature(1,3) L <- list(     C     = basis(numeric()),     e12   = basis(c(1,2)), e13 = basis(c(1,3)),     e14   = basis(c(1,4)), e23 = basis(c(2,3)),     e24   = basis(c(2,4)), e34 = basis(c(3,4)),     e1234 = basis(1:4) )   out <- noquote(matrix(\"\",8,8)) rownames(out) <- names(L) colnames(out) <- names(L) for(i in 1:8){   for(j in 1:8){     out[i,j] <- gsub('[_ ]','',as.character(L[[i]]*L[[j]]))   } } options(\"width\" = 110) out ##       C       e12     e13     e14     e23     e24     e34     e1234   ## C     1       +1e12   +1e13   +1e14   +1e23   +1e24   +1e34   +1e1234 ## e12   +1e12   1       -1e23   -1e24   -1e13   -1e14   +1e1234 +1e34   ## e13   +1e13   +1e23   1       -1e34   +1e12   -1e1234 -1e14   -1e24   ## e14   +1e14   +1e24   +1e34   1       +1e1234 +1e12   +1e13   +1e23   ## e23   +1e23   +1e13   -1e12   +1e1234 -1      +1e34   -1e24   -1e14   ## e24   +1e24   +1e14   -1e1234 -1e12   -1e34   -1      +1e23   +1e13   ## e34   +1e34   +1e1234 +1e14   -1e13   +1e24   -1e23   -1      -1e12   ## e1234 +1e1234 +1e34   -1e24   +1e23   -1e14   +1e13   -1e12   -1"},{"path":[]},{"path":"https://robinhankin.github.io/clifford/articles/pauli_clifford.html","id":"implementation","dir":"Articles","previous_headings":"","what":"Implementation","title":"Pauli matrices via Clifford algebra","text":"Let us start Pauli matrices: \\[ \\sigma_0=\\left(\\begin{matrix}1&0\\\\0&1\\end{matrix}\\right)\\qquad \\sigma_x=\\left(\\begin{matrix}0&1\\\\1&0\\end{matrix}\\right)\\qquad \\sigma_y=\\left(\\begin{matrix}0&-\\\\&0\\end{matrix}\\right)\\qquad \\sigma_z=\\left(\\begin{matrix}1&0\\\\0&-1\\end{matrix}\\right) \\] \\[ \\sigma_0=\\left(\\begin{matrix}&0\\\\0&\\end{matrix}\\right)\\qquad \\sigma_x=\\left(\\begin{matrix}0&\\\\&0\\end{matrix}\\right)\\qquad \\sigma_y=\\left(\\begin{matrix}0&1\\\\-1&0\\end{matrix}\\right)\\qquad \\sigma_z=\\left(\\begin{matrix}&0\\\\0&-\\end{matrix}\\right) \\] Given general complex matrix \\[ \\left(\\begin{matrix} \\alpha  +\\beta  &  \\gamma+\\delta \\\\ \\epsilon+\\zeta  &  \\eta+\\theta   \\end{matrix}\\right) \\] see \\[\\begin{eqnarray} \\sigma_0&=(\\alpha+\\eta)/2\\qquad \\sigma_0=(\\beta+\\theta)/2\\\\ \\sigma_x&=(\\gamma+\\epsilon)/2\\qquad \\sigma_x=(\\delta+\\xi)/2\\\\ \\sigma_y&=(\\gamma-\\epsilon)/2\\qquad \\sigma_x=(\\delta-\\xi)/2\\\\ \\sigma_z&=(\\alpha-\\eta)/2\\qquad \\sigma_z=(\\beta-\\theta)/2\\\\ \\end{eqnarray}\\]","code":""},{"path":"https://robinhankin.github.io/clifford/articles/pauli_clifford.html","id":"r-implementation","dir":"Articles","previous_headings":"","what":"R implementation","title":"Pauli matrices via Clifford algebra","text":"Given general complex matrix M, may coerce Clifford form follows: test follows: can now test whether matrix_to_clifford() group homomorphism: see agreement numerical precision. Now can coerce Clifford matrix: Now test two coercion functions inverses one another: Now can establish clifford_to_matrix() homomorphism:","code":"s0 <- matrix(c(1,0,0,1),2,2) sx <- matrix(c(0,1,1,0),2,2) sy <- matrix(c(0,1i,-1i,0),2,2) sz <- matrix(c(1,0,0,-1),2,2) matrix_to_clifford <- function(M){       (Re(M[1,1] + M[2,2]))/2             +        (Re(M[1,1] - M[2,2]))/2*e(c(  3  )) +       (Im(M[1,1] + M[2,2]))/2*e(c(1,2,3)) +        (Im(M[1,1] - M[2,2]))/2*e(c(1,2  )) +        (Re(M[2,1] + M[1,2]))/2*e(c(1    )) +        (Re(M[2,1] - M[1,2]))/2*e(c(1,  3)) +       (Im(M[2,1] + M[1,2]))/2*e(c(  2,3)) +        (Im(M[2,1] - M[1,2]))/2*e(c(  2  )) } rmat <- function(...){matrix(rnorm(4),2,2) + 1i*matrix(rnorm(4),2,2)} M <- rmat() M ##                       [,1]                    [,2] ## [1,] -1.4000435+0.6215527i -2.437263611-1.8218177i ## [2,]  0.2553171+1.1484116i -0.005571287-0.2473253i matrix_to_clifford(M) ## Element of a Clifford algebra, equal to ## - 0.7028074 - 1.090973e_1 + 1.485115e_2 + 0.434439e_12 - 0.6972361e_3 + ## 1.34629e_13 - 0.336703e_23 + 0.1871137e_123 M1 <- rmat() M2 <- rmat()  diff <- matrix_to_clifford(M1)*matrix_to_clifford(M2) - matrix_to_clifford(M1 %*% M2) diff ## Element of a Clifford algebra, equal to ## + 2.220446e-16e_12 + 8.326673e-17e_3 + 2.220446e-16e_23 - 8.326673e-17e_123 Mod(diff) ## [1] 3.353719e-16 `clifford_to_matrix` <- function(C){    return(                           const(C)*s0 + getcoeffs(C,list(1))*sx    +           getcoeffs(C,list(2))*sy + getcoeffs(C,list(3))*sz   + getcoeffs(C,list(c(1,2,3)))*1i*s0 + getcoeffs(C,list(c(  2,3)))*1i*sx    - getcoeffs(C,list(c(1,  3)))*1i*sy + getcoeffs(C,list(c(1,2  )))*1i*sz   ) } rc <- function(...){rcliff(100,d=3,g=3)} C <- 104 + rc() C ## Element of a Clifford algebra, equal to ## + 155 + 60e_1 - 90e_2 + 74e_12 - 63e_3 + 10e_13 + 27e_23 - 27e_123 clifford_to_matrix(C) ##        [,1]     [,2] ## [1,] 92+47i  50+117i ## [2,] 70-63i 218-101i clifford_to_matrix(matrix_to_clifford(M)) - M ##      [,1]                        [,2] ## [1,] 0+0i  0.000000e+00+2.220446e-16i ## [2,] 0+0i -7.372575e-17+2.775558e-17i matrix_to_clifford(clifford_to_matrix(C))- C ## Element of a Clifford algebra, equal to ## the zero clifford element (0) C1 <- 222 + rc() C2 <- 333 + rc() clifford_to_matrix(C1*C2) - clifford_to_matrix(C1)%*%clifford_to_matrix(C2) ##      [,1] [,2] ## [1,] 0+0i 0+0i ## [2,] 0+0i 0+0i"},{"path":"https://robinhankin.github.io/clifford/articles/pauli_clifford.html","id":"closure","dir":"Articles","previous_headings":"R implementation","what":"Closure","title":"Pauli matrices via Clifford algebra","text":"reason Pauli matrices useful physics closed Jordan operation \\(x\\circ y=(xy+yx)/2\\), verify matrices Clifford representation. , see \\(M_1\\circ M_2\\) Hermitian. Now, Clifford form: , see clifford product p2 pure Pauli matrix nonzero coefficients scalar grade-one blades:","code":"M1 <- as.1matrix(rchm(1,2)) M2 <- as.1matrix(rchm(1,2)) M1 ##             [,1]        [,2] ## [1,] -0.05+0.00i -0.74-0.11i ## [2,] -0.74+0.11i -0.56+0.00i M2 ##             [,1]       [,2] ## [1,] -0.56+0.00i 0.75-1.92i ## [2,]  0.75+1.92i 0.19+0.00i p1 <- (M1 %*% M2 + M2 %*% M1)/2 p1 - ht(p1)  # zero for Hermitian matrices ##      [,1] [,2] ## [1,] 0+0i 0+0i ## [2,] 0+0i 0+0i C1 <- matrix_to_clifford(M1) C2 <- matrix_to_clifford(M2) p2 <- (C1 * C2 + C2 * C1)/2 p2 ## Element of a Clifford algebra, equal to ## - 0.383 - 0.09185e_1 - 0.60595e_2 + 0.0672e_3 grades(p2) ## A disord object with hash dc0ef121a24b8ab8c67bbfc6468e439b5622e81e and elements ## [1] 0 1 1 1 ## (in some order)"},{"path":[]},{"path":[]},{"path":"https://robinhankin.github.io/clifford/articles/quaternion_clifford.html","id":"alternative-mapping","dir":"Articles","previous_headings":"","what":"Alternative mapping","title":"Quaternionic arithmetic with Clifford algebra","text":"Alternatively might consider even subalgebra \\(\\operatorname{Cl}(0,3)\\) general element \\(q_0 + q_1e_{23} -q_2e_{13} + q_3e_{12}\\) (note change sign \\(q_2\\)). Thus \\[ \\mathbf{}\\leftrightarrow e_{23}\\\\ \\mathbf{j}\\leftrightarrow -e_{13}\\\\ \\mathbf{k}\\leftrightarrow e_{12}\\\\ \\] quick--dirty R function might verification straightforward:","code":"signature(0,3) cliff2quat <- function(C){   out <- getcoeffs(C,list(numeric(0),c(2,3),c(1,3),c(1,2)))   out[2] <- -out[2]   as.quaternion(out,single=TRUE) }  quat2cliff <- function(H){   jj <- c(as.matrix(H))   jj[2] <- -jj[2]   clifford(list(numeric(0),c(2,3),c(1,3),c(1,2)),jj) } c(   cliff2quat(quat2cliff(H1)) == H1,   cliff2quat(quat2cliff(H2)) == H2,   quat2cliff(cliff2quat(q1)) == q1,   quat2cliff(cliff2quat(q2)) == q2,   cliff2quat(q1*q2) == cliff2quat(q1) * cliff2quat(q2),   quat2cliff(H1*H2) == quat2cliff(H1) * quat2cliff(H2) ) ## [1] TRUE TRUE TRUE TRUE TRUE TRUE"},{"path":[]},{"path":[]},{"path":"https://robinhankin.github.io/clifford/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Robin K. S. Hankin. Author, maintainer.","code":""},{"path":"https://robinhankin.github.io/clifford/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Hankin RKS (????). clifford: Arbitrary Dimensional Clifford Algebras. R package version 1.1-1, https://github.com/RobinHankin/clifford. Robin K. S. Hankin (2025). “Clifford algebra R: introducing clifford package.” Advances Applied Clifford Algebra. doi:10.1007/s00006-025-01403-9.","code":"@Manual{,   title = {clifford: Arbitrary Dimensional Clifford Algebras},   author = {Robin K. S. Hankin},   note = {R package version 1.1-1},   url = {https://github.com/RobinHankin/clifford}, } @Article{,   title = {Clifford algebra in R: introducing the clifford package},   author = {{Robin K. S. Hankin}},   journal = {Advances in Applied Clifford Algebra},   year = {2025},   doi = {10.1007/s00006-025-01403-9}, }"},{"path":"https://robinhankin.github.io/clifford/index.html","id":"the-clifford-package-clifford-algebra-in-r","dir":"","previous_headings":"","what":"Arbitrary Dimensional Clifford Algebras","title":"Arbitrary Dimensional Clifford Algebras","text":"clifford package provides R-centric functionality working Clifford algebras arbitrary dimension signature. detailed vignette provided package.","code":""},{"path":"https://robinhankin.github.io/clifford/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Arbitrary Dimensional Clifford Algebras","text":"can install released version clifford package CRAN :","code":"# install.packages(\"clifford\")  # uncomment this to install the package library(\"clifford\") set.seed(0)"},{"path":"https://robinhankin.github.io/clifford/index.html","id":"the-clifford-package-in-use","dir":"","previous_headings":"","what":"The clifford package in use","title":"Arbitrary Dimensional Clifford Algebras","text":"basic creation function clifford(), takes list basis blades vector coefficients: b multivectors. Clifford objects vector space can add using +: See e2 term vanishes e_23 term summed. package includes large number products: package can deal non positive-definite inner products. Suppose wish deal inner product  diagonal number  terms followed number  terms. package idiom use signature(): Function signature() based lorentz::sol() argument specifies number basis blades square , others squaring . Thus  : package uses STL map class dynamic bitset keys efficiency speed can deal objects arbitrary dimensions. Thus:","code":"(a <- clifford(list(1,2,1:4,2:3),1:4)) #> Element of a Clifford algebra, equal to #> + 1e_1 + 2e_2 + 4e_23 + 3e_1234 (b <- clifford(list(2,2:3,1:2),c(-2,3,-3))) #> Element of a Clifford algebra, equal to #> - 2e_2 - 3e_12 + 3e_23 a+b #> Element of a Clifford algebra, equal to #> + 1e_1 - 3e_12 + 7e_23 + 3e_1234 a*b        # geometric product (also \"a % % b\") #> Element of a Clifford algebra, equal to #> - 16 + 6e_1 - 3e_2 - 2e_12 + 14e_3 + 12e_13 + 3e_123 - 9e_14 + 9e_34 - 6e_134 a %^% b    # outer product #> Element of a Clifford algebra, equal to #> - 2e_12 + 3e_123 a %.% b    # inner product #> Element of a Clifford algebra, equal to #> - 16 + 6e_1 - 3e_2 + 14e_3 - 9e_14 + 9e_34 - 6e_134 a %star% b # scalar product #> [1] -16 a %euc% b  # Euclidean product #> [1] 8 signature(3) basis(1) #> Element of a Clifford algebra, equal to #> + 1e_1 basis(1)^2 #> Element of a Clifford algebra, equal to #> scalar ( 1 ) basis(4) #> Element of a Clifford algebra, equal to #> + 1e_4 basis(4)^2 #> Element of a Clifford algebra, equal to #> the zero clifford element (0) options(\"basissep\" = \",\") (x <- rcliff(d=20)) #> Element of a Clifford algebra, equal to #> + 5 - 1e_2 + 6e_5 + 2e_4,7 - 3e_10 - 5e_11 + 3e_14 + 1e_10,14 + 4e_5,9,15 + #> 9e_18,19 summary(x^3) #> Element of a Clifford algebra  #> Typical terms:  140  ...  + 216e_5,9,10,14,15,18,19  #> Number of terms: 44  #> Magnitude: 25376"},{"path":"https://robinhankin.github.io/clifford/index.html","id":"references","dir":"","previous_headings":"","what":"References","title":"Arbitrary Dimensional Clifford Algebras","text":"D. Hestenes 1987. Clifford algebra geometric calculus, Kluwer. J. Snygg 2010. new approach differential geometry using Clifford’s geometric algebra. Berghauser. C. Perwass 2009. Geometric algebra applications engineering. Springer.","code":""},{"path":"https://robinhankin.github.io/clifford/index.html","id":"further-information","dir":"","previous_headings":"","what":"Further information","title":"Arbitrary Dimensional Clifford Algebras","text":"detail, see package vignette vignette(\"clifford\")","code":""},{"path":"https://robinhankin.github.io/clifford/reference/Extract.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract or Replace Parts of a clifford — Extract.clifford","title":"Extract or Replace Parts of a clifford — Extract.clifford","text":"Extract replace subsets cliffords.","code":""},{"path":"https://robinhankin.github.io/clifford/reference/Extract.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract or Replace Parts of a clifford — Extract.clifford","text":"","code":"# S3 method for class 'clifford' C[index, ..., drop = FALSE] # S3 method for class 'clifford' C[index, ...] <- value coeffs(x) coeffs(x) <- value list_modifier(B) getcoeffs(C, B) # S3 method for class 'clifford' Im(z) # S3 method for class 'clifford' Re(z)"},{"path":"https://robinhankin.github.io/clifford/reference/Extract.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract or Replace Parts of a clifford — Extract.clifford","text":"C,x,z clifford object index elements extract replace value replacement value B list integer vectors, terms drop Boolean: constant clifford objects       coerced numeric? ... arguments","code":""},{"path":"https://robinhankin.github.io/clifford/reference/Extract.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Extract or Replace Parts of a clifford — Extract.clifford","text":"Extraction replacement methods.  extraction method uses getcoeffs() replacement method uses low-level helper function c_overwrite(). extraction function [index], index list, arguments ignored; , dots used.  index list, elements interpreted integer vectors indicating terms extracted (even disord object).  index disord object, standard consistency rules applied.  extraction methods designed idiom [coeffs()>3] works. replacement methods, standard use-case [] <- b argument list integer vectors b length-one numeric vector; (replacement vectors length greater one currently implemented, whether violate disordR discipline).  Otherwise, manipulate parts clifford object, use coeffs() <- value; disord discipline enforced.  Idiom [coeffs()<2] <- 0 implemented experimentally, syntactic sugar coeffs()[coeffs()<2] <- 0.  Replacement using list-valued index, [] <- value uses ugly hack value zero.  Replacement methods yet finalised yet fully integrated disordR package. Idiom [] <- b follows spray package.  b length-one scalar, coeffs() <- b effect [] <- b. Grade-based replacement methods grade(C,n) <- value impemented documented grade.Rd. Functions terms() [see term.Rd] coeffs() extract terms coefficients clifford object.  functions return disord objects ordering consistent (extended discussion phenomenon presented mvp package).  Note coeffs() returns numeric(0) zero clifford object. Function coeffs<-() (idiom coeffs() <- b) sets coefficients b.  effect [] <- b. Extracting replacing list repeated elements usually Bad Idea (tm).  However, option warn_on_repeats set FALSE, warning given (coefficient sum coefficients term; see examples). Function getcoeffs() lower-level helper function lacks succour offered [.clifford().  returns named numeric vector [disord object: order elements determined order argument B].  Compare standard extraction, eg [index], returns clifford object.  names returned vector determined function catterm(). Attempting extract coefficient term includes negative index throw error.  coefficient term present Clifford object (including term index larger indicated maxyterm()) return zero. index constant formally list(numeric(0)), pain type.  Square bracket extraction getcoeffs() special dispensation zero entries, translated helper function list_modifier() numeric(0) listified necessary.  upshot x[0] getcoeffs(x,0) work expected, returning constant. Function Im() generic, sets real component argument zero (per onion package).  Function Re() convenience synonym const(). Vignette getcoeffs gives extended discussion function getcoeffs().","code":""},{"path":[]},{"path":"https://robinhankin.github.io/clifford/reference/Extract.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Extract or Replace Parts of a clifford — Extract.clifford","text":"","code":"A <- clifford(list(1,1:2,1:3),1:3) B <- clifford(list(1:2,1:6),c(44,45))  A[1,c(1,3,4)] #> Element of a Clifford algebra, equal to #> + 1e_1  A[2:3, 4] <- 99 A[] <- B    X <- 5 + 6*e(1) -7*e(1:3) + 3*e(4:5) X[0]           # special dispensation for zero #> Element of a Clifford algebra, equal to #> scalar ( 5 ) X[0,drop=TRUE] # coerce to numeric #> [1] 5 X[list(0,1:3)]  #> Element of a Clifford algebra, equal to #> + 5 - 7e_123  getcoeffs(X,0) #> e_0  #>   5  getcoeffs(X,list(1,0,1:3)) #>   e_1   e_0 e_123  #>     6     5    -7   # clifford(list(1,1:2,1:2),1:3)  # would give a warning  options(\"warn_on_repeats\" = FALSE) clifford(list(1,1:2,1:2),1:3)  # works; 1e1 + 5e_12 #> Element of a Clifford algebra, equal to #> + 1e_1 + 5e_12  options(\"warn_on_repeats\" = TRUE) # return to default behaviour."},{"path":"https://robinhankin.github.io/clifford/reference/Ops.clifford.html","id":null,"dir":"Reference","previous_headings":"","what":"Arithmetic Ops Group Methods for clifford objects — Ops.clifford","title":"Arithmetic Ops Group Methods for clifford objects — Ops.clifford","text":"Different arithmetic operators clifford objects, including   many different types multiplication.","code":""},{"path":"https://robinhankin.github.io/clifford/reference/Ops.clifford.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Arithmetic Ops Group Methods for clifford objects — Ops.clifford","text":"","code":"# S3 method for class 'clifford' Ops(e1, e2) clifford_negative(C) geoprod(C1, C2) clifford_times_scalar(C, x) clifford_plus_clifford(C1, C2) clifford_eq_clifford(C1, C2) clifford_inverse(C) cliffdotprod(C1, C2) fatdot(C1, C2) lefttick(C1, C2) righttick(C1, C2) wedge(C1,C2) scalprod(C1, C2=rev(C1), drop=TRUE) eucprod(C1, C2=C1, drop=TRUE) maxyterm(C1, C2=as.clifford(0)) C1 %.% C2 C1 %dot% C2 C1 %^% C2 C1 %X% C2 C1 %star% C2 C1 % % C2 C1 %euc% C2 C1 %o% C2 C1 %_|% C2 C1 %|_% C2"},{"path":"https://robinhankin.github.io/clifford/reference/Ops.clifford.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Arithmetic Ops Group Methods for clifford objects — Ops.clifford","text":"e1, e2, C, C1, C2 Objects class clifford coerced     needed x Scalar, length one numeric vector drop Boolean, default TRUE meaning return     constant coerced numeric, FALSE meaning return     (constant) Clifford object","code":""},{"path":"https://robinhankin.github.io/clifford/reference/Ops.clifford.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Arithmetic Ops Group Methods for clifford objects — Ops.clifford","text":"function Ops.clifford() passes unary binary arithmetic   operators “+”, “-”, “*”,   “/” “^” appropriate specialist   function.  Function maxyterm() returns maximum index   terms arguments. package several binary operators:  R idiom, geometric product geoprod(.,.)   indicated “*” (*B)   binary operator must %*%: need different idiom   scalar product, %star% used. geometric product often denoted juxtaposition, package   idiom includes % % b geometric product. Binary operator %dot% synonym %.%,   causes problems rmarkdown. Function clifford_inverse() returns inverse nonnull   Clifford objects \\(\\operatorname{Cl}(p,q)\\)   \\(p+q\\leq 5\\), special cases.    functionality problematic nonnull blades always inverse;   function .blade() yet implemented.  Blades   (including null blades) pseudoinverse,   implemented yet either. scalar product two clifford objects defined   zero-grade component geometric product: $$     \\ast B=\\left\\langle AB\\right\\rangle_0\\qquad{\\mbox{NB: notation used Perwass Hestenes}}   $$ package idiom scalar product given %star% B   scalprod(,B).  Hestenes Perwass use asterisk   scalar product “\\(*B\\)”, package idiom,   asterisk reserved geometric product. Note: package, *B geometric product. Euclidean product (Euclidean scalar product) two   clifford objects defined $$     \\star B=     \\ast B^\\dagger=     \\left\\langle AB^\\dagger\\right\\rangle_0\\qquad{\\mbox{Perwass}}   $$ \\(B^\\dagger\\) denotes Conjugate [Conj()].    package idiom Euclidean scalar product given   eucprod(,B) %euc% B, return   * Conj(B). Note scalar product \\(\\ast \\) can positive   negative [, %star% may sign],   Euclidean product guaranteed non-negative [,   %euc% always positive zero]. Dorst defines left right contraction (Chisholm calls   left right inner product) \\(\\rfloor B\\)   \\(\\lfloor B\\).  See vignette details. Division, idiom x/y, defined   x*clifford_inverse(y).  Function clifford_inverse() uses   method set Hitzer Sangwine limited   \\(p+q\\leq 5\\). Lie bracket, \\(\\left[x,y\\right]\\) implemented   package using idiom .[x,y], documented   dot.Rd. Many functions documented use low-level helper functions   wrap C code.  example, fatdot() uses   c_fatdotprod().  documented lowlevel.Rd.","code":""},{"path":"https://robinhankin.github.io/clifford/reference/Ops.clifford.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Arithmetic Ops Group Methods for clifford objects — Ops.clifford","text":"high-level functions documented return clifford   object.  low-level functions really intended   end-user.","code":""},{"path":"https://robinhankin.github.io/clifford/reference/Ops.clifford.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Arithmetic Ops Group Methods for clifford objects — Ops.clifford","text":"Robin K. S. Hankin","code":""},{"path":[]},{"path":"https://robinhankin.github.io/clifford/reference/Ops.clifford.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Arithmetic Ops Group Methods for clifford objects — Ops.clifford","text":"different Clifford products binary operators   convenience including wedge product %^%.  However,   experimental facility, caret “^” returns either   multiplicative powers [^3=**], wedge product [  ^B = %^% B = wedge(,B)] depending class   second argument.  see “^ B”   ambiguous OTOH might withdraw proves unsatisfactory   reason. Compare stokes package, multiplicative powers   really make sense ^B interpreted wedge product   differential forms \\(\\) \\(B\\).  stokes,   wedge product sine qua non whole package   needs terse idiomatic representation (although %^%B   returns wedge product ). Using %.% causes severe weird difficult--debug   problems markdown documents.","code":""},{"path":"https://robinhankin.github.io/clifford/reference/Ops.clifford.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Arithmetic Ops Group Methods for clifford objects — Ops.clifford","text":"E. Hitzer S. Sangwine 2017.  “Multivector multivector   matrix inverses real Clifford algebras”.  Applied Mathematics   Computation 311:375-389","code":""},{"path":"https://robinhankin.github.io/clifford/reference/Ops.clifford.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Arithmetic Ops Group Methods for clifford objects — Ops.clifford","text":"","code":"u <- rcliff(5) v <- rcliff(5) w <- rcliff(5)  u #> Element of a Clifford algebra, equal to #> + 4 - 1e_5 + 4e_35 + 2e_145 + 5e_6 - 2e_36 v #> Element of a Clifford algebra, equal to #> + 3 - 2e_4 + 1e_125 + 3e_1236 + 2e_1246 - 4e_256 u*v #> Element of a Clifford algebra, equal to #> + 12 + 5e_12 - 11e_123 - 8e_4 + 2e_24 - 10e_124 + 4e_1234 - 3e_5 + 4e_15 - #> 20e_25 + 4e_125 + 12e_35 - 8e_235 - 2e_45 + 6e_145 + 8e_345 + 15e_6 - 4e_26 - #> 6e_36 - 16e_236 + 12e_1236 + 10e_46 - 4e_346 - 20e_256 - 17e_1256 + 5e_12356 + #> 2e_12456 + 6e_23456 - 8e_123456  u+(v+w) == (u+v)+w            # should be TRUE by associativity of \"+\" #> [1] TRUE u*(v*w) == (u*v)*w            # should be TRUE by associativity of \"*\" #> [1] TRUE u*(v+w) == u*v + u*w          # should be TRUE by distributivity #> [1] TRUE  # Now if x,y are _vectors_ we have:  x <- as.1vector(sample(5)) y <- as.1vector(sample(5)) x*y == x%.%y + x%^%y #> [1] TRUE x %^% y == x %^% (y + 3*x)   #> [1] TRUE x %^% y == (x*y-x*y)/2        # should be TRUE  #> [1] FALSE  #  above are TRUE for x,y vectors (but not for multivectors, in general)   ## Inner product \"%.%\" is not associative: x <- rcliff(5, g=2) y <- rcliff(5, g=2) z <- rcliff(5, g=2) x %.% (y %.% z) == (x %.% y) %.% z #> [1] FALSE  ## Other products should work as expected:  x %|_% y   ## left contraction #> Element of a Clifford algebra, equal to #> + 28 + 4e_2 - 16e_3 + 5e_4 - 4e_24 + 8e_5 + 20e_15 + 4e_56 x %_|% y   ## right contraction #> Element of a Clifford algebra, equal to #> + 28 + 12e_1 + 20e_2 - 10e_3 + 12e_13 - 16e_4 + 4e_5 - 4e_35 x %o% y    ## fat dot product #> Element of a Clifford algebra, equal to #> + 28 + 12e_1 + 24e_2 - 26e_3 + 12e_13 - 11e_4 - 4e_24 + 12e_5 + 20e_15 - 4e_35 #> + 4e_56 x ^ y        ## Experimental wedge product idiom, plain caret #> Element of a Clifford algebra, equal to #> + 16 + 20e_2 - 28e_3 + 12e_13 + 20e_23 - 16e_4 - 4e_24 + 16e_34 - 3e_234 + #> 3e_1234 + 8e_5 + 20e_15 - 10e_25 - 25e_125 + 2e_35 + 21e_135 + 8e_45 + 20e_145 #> - 1e_2345 + 4e_56 + 5e_256 - 3e_356 + 3e_1356 - 4e_456"},{"path":"https://robinhankin.github.io/clifford/reference/allcliff.html","id":null,"dir":"Reference","previous_headings":"","what":"Clifford object containing all possible terms — allcliff","title":"Clifford object containing all possible terms — allcliff","text":"Clifford algebra basis vectors \\(e_1,e_2,\\ldots,   e_n\\) \\(2^n\\) independent multivectors.  Function   allcliff() generates clifford object nonzero   coefficient multivector.","code":""},{"path":"https://robinhankin.github.io/clifford/reference/allcliff.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Clifford object containing all possible terms — allcliff","text":"","code":"allcliff(n,grade)"},{"path":"https://robinhankin.github.io/clifford/reference/allcliff.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Clifford object containing all possible terms — allcliff","text":"n Integer specifying dimension underlying vector space grade Grade multivector returned.  missing,     multivector contains every term every grade \\(\\leq n\\)","code":""},{"path":"https://robinhankin.github.io/clifford/reference/allcliff.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Clifford object containing all possible terms — allcliff","text":"Robin K. S. Hankin","code":""},{"path":"https://robinhankin.github.io/clifford/reference/allcliff.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Clifford object containing all possible terms — allcliff","text":"","code":"allcliff(6) #> Element of a Clifford algebra, equal to #> + 1 + 1e_1 + 1e_2 + 1e_12 + 1e_3 + 1e_13 + 1e_23 + 1e_123 + 1e_4 + 1e_14 + #> 1e_24 + 1e_124 + 1e_34 + 1e_134 + 1e_234 + 1e_1234 + 1e_5 + 1e_15 + 1e_25 + #> 1e_125 + 1e_35 + 1e_135 + 1e_235 + 1e_1235 + 1e_45 + 1e_145 + 1e_245 + 1e_1245 #> + 1e_345 + 1e_1345 + 1e_2345 + 1e_12345 + 1e_6 + 1e_16 + 1e_26 + 1e_126 + 1e_36 #> + 1e_136 + 1e_236 + 1e_1236 + 1e_46 + 1e_146 + 1e_246 + 1e_1246 + 1e_346 + #> 1e_1346 + 1e_2346 + 1e_12346 + 1e_56 + 1e_156 + 1e_256 + 1e_1256 + 1e_356 + #> 1e_1356 + 1e_2356 + 1e_12356 + 1e_456 + 1e_1456 + 1e_2456 + 1e_12456 + 1e_3456 #> + 1e_13456 + 1e_23456 + 1e_123456  a <- allcliff(5) a[] <- rcliff()*100"},{"path":"https://robinhankin.github.io/clifford/reference/antivector.html","id":null,"dir":"Reference","previous_headings":"","what":"Antivectors or pseudovectors — antivector","title":"Antivectors or pseudovectors — antivector","text":"Antivectors pseudovectors","code":""},{"path":"https://robinhankin.github.io/clifford/reference/antivector.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Antivectors or pseudovectors — antivector","text":"","code":"antivector(v, n = length(v)) as.antivector(v) is.antivector(C, include.pseudoscalar=FALSE)"},{"path":"https://robinhankin.github.io/clifford/reference/antivector.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Antivectors or pseudovectors — antivector","text":"v Numeric vector n Integer specifying dimensionality underlying vector space C Clifford object include.pseudoscalar Boolean: pseudoscalar     considered antivector?","code":""},{"path":"https://robinhankin.github.io/clifford/reference/antivector.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Antivectors or pseudovectors — antivector","text":"antivector \\(n\\)-dimensional Clifford object, whose terms grade \\(n-1\\).  antivector \\(n\\) degrees freedom.  Function antivector(v,n) interprets v[] coefficient \\(e_1e_2\\ldots e_{-1}e_{+1}\\ldots e_n\\). Function .antivector() convenience wrapper, coercing argument antivector minimal dimension (zero entries interpreted consistently). pseudoscalar peculiar edge case.  Consider: One argue antivector term B, definitely antivector.  Use include.pseudoscalar=TRUE ensure consistency case. Compare .1vector(), returns clifford object grade 1.","code":"A <- clifford(list(c(1,2,3)))   B <- A + clifford(list(c(1,2,4)))  > is.antivector(A) [1] FALSE > is.antivector(B) [1] TRUE > is.antivector(A,include.pseudoscalar=TRUE) [1] TRUE > is.antivector(B,include.pseudoscalar=TRUE) [1] TRUE"},{"path":"https://robinhankin.github.io/clifford/reference/antivector.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Antivectors or pseudovectors — antivector","text":"antivector always blade.","code":""},{"path":"https://robinhankin.github.io/clifford/reference/antivector.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Antivectors or pseudovectors — antivector","text":"Wikipedia contributors. (2018, July 20). “Antivector”.    Wikipedia, Free Encyclopedia. Retrieved 19:06, January 27,   2020,   https://en.wikipedia.org/w/index.php?title=Antivector&oldid=851094060","code":""},{"path":"https://robinhankin.github.io/clifford/reference/antivector.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Antivectors or pseudovectors — antivector","text":"Robin K. S. Hankin","code":""},{"path":[]},{"path":"https://robinhankin.github.io/clifford/reference/antivector.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Antivectors or pseudovectors — antivector","text":"","code":"antivector(1:5) #> Element of a Clifford algebra, equal to #> + 5e_1234 + 4e_1235 + 3e_1245 + 2e_1345 + 1e_2345  as.1vector(c(1,1,2)) %X% as.1vector(c(3,2,2)) #> Element of a Clifford algebra, equal to #> - 1e_12 - 4e_13 - 2e_23 c(1*2-2*2, 2*3-1*2, 1*2-1*3)  # note sign of e_13 #> [1] -2  4 -1"},{"path":"https://robinhankin.github.io/clifford/reference/cartan.html","id":null,"dir":"Reference","previous_headings":"","what":"Cartan map between clifford algebras — cartan","title":"Cartan map between clifford algebras — cartan","text":"Cartan's map isomorphisms \\(\\operatorname{Cl}(p,q)\\)   \\(\\operatorname{Cl}(p-4,q+4)\\)   \\(\\operatorname{Cl}(p+4,q-4)\\)","code":""},{"path":"https://robinhankin.github.io/clifford/reference/cartan.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Cartan map between clifford algebras — cartan","text":"","code":"cartan(C, n = 1) cartan_inverse(C, n = 1)"},{"path":"https://robinhankin.github.io/clifford/reference/cartan.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Cartan map between clifford algebras — cartan","text":"C Object class clifford n Strictly positive integer","code":""},{"path":"https://robinhankin.github.io/clifford/reference/cartan.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Cartan map between clifford algebras — cartan","text":"Returns object class clifford.  default value   n=1 maps \\(\\operatorname{Cl}(4,q)\\)   \\(\\operatorname{Cl}(0,q+4)\\) (cartan())   \\(\\operatorname{Cl}(0,q)\\)   \\(\\operatorname{Cl}(4,q-4)\\).","code":""},{"path":"https://robinhankin.github.io/clifford/reference/cartan.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Cartan map between clifford algebras — cartan","text":"E. Hitzer S. Sangwine 2017.  “Multivector multivector matrix inverses real Clifford algebras”, Applied Mathematics Computation. 311:3755-89","code":""},{"path":"https://robinhankin.github.io/clifford/reference/cartan.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Cartan map between clifford algebras — cartan","text":"Robin K. S. Hankin","code":""},{"path":[]},{"path":"https://robinhankin.github.io/clifford/reference/cartan.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Cartan map between clifford algebras — cartan","text":"","code":"a <- rcliff(d=7)   # Cl(4,3) b <- rcliff(d=7)   # Cl(4,3) signature(4, 3)    # e1^2 = e2^2 = e3^2 = e4^2 = +1; e5^2 = e6^2=e7^2 = -1 ab <- a*b          # multiplication in Cl(4,3)  signature(0, 7)   # e1^2 = ... = e7^2 = -1 cartan(a)*cartan(b) == cartan(ab) # multiplication in Cl(0,7); should be TRUE #> [1] TRUE  signature(Inf)  # restore default"},{"path":"https://robinhankin.github.io/clifford/reference/clifford-package.html","id":null,"dir":"Reference","previous_headings":"","what":"Arbitrary Dimensional Clifford Algebras — clifford-package","title":"Arbitrary Dimensional Clifford Algebras — clifford-package","text":"suite routines Clifford algebras, using    'Map' class Standard Template Library.  Canonical    reference: Hestenes (1987, ISBN 90-277-1673-0, \"Clifford algebra    geometric calculus\").  Special cases including Lorentz transforms,    quaternion multiplication, Grassmann algebra, discussed.    Vignettes presenting conformal geometric algebra, quaternions    split quaternions, dual numbers, Lorentz transforms    included.  package follows 'disordR' discipline.","code":""},{"path":"https://robinhankin.github.io/clifford/reference/clifford-package.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Arbitrary Dimensional Clifford Algebras — clifford-package","text":"DESCRIPTION file: package yet installed build time.   Index:  package yet installed build time.","code":""},{"path":"https://robinhankin.github.io/clifford/reference/clifford-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Arbitrary Dimensional Clifford Algebras — clifford-package","text":"Robin K. S. Hankin [aut, cre] (ORCID:     <https://orcid.org/0000-0001-5982-0415>) Maintainer: Robin K. S. Hankin <hankin.robin@gmail.com>","code":""},{"path":"https://robinhankin.github.io/clifford/reference/clifford-package.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Arbitrary Dimensional Clifford Algebras — clifford-package","text":"R. K. S. Hankin (2025).  “Clifford algebra R:       introducing clifford package”.  Advances       Applied Clifford Algebra,     doi:10.1007/s00006-025-01403-9 J. Snygg (2012).  new approach differential       geometry using Clifford's geometric Algebra, Birkhauser.  ISBN     978-0-8176-8282-8 D. Hestenes (1987). Clifford algebra geometric       calculus,  Kluwer. ISBN 90-277-1673-0 C. Perwass (2009). Geometric algebra applications       engineering, Springer.  ISBN 978-3-540-89068-3 D. Hildenbrand (2013). Foundations geometric       algebra computing.  Springer, ISBN 978-3-642-31794-1","code":""},{"path":[]},{"path":"https://robinhankin.github.io/clifford/reference/clifford-package.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Arbitrary Dimensional Clifford Algebras — clifford-package","text":"","code":"as.1vector(1:4) #> Element of a Clifford algebra, equal to #> + 1e_1 + 2e_2 + 3e_3 + 4e_4  as.1vector(1:4) * rcliff() #> Element of a Clifford algebra, equal to #> + 6e_1 - 9e_2 + 12e_12 + 32e_3 - 8e_13 + 4e_23 + 7e_123 + 24e_4 + 28e_234 - #> 16e_1234 + 6e_5 + 8e_15 + 16e_25 + 32e_35 + 2e_135 + 4e_235 + 26e_45 - 8e_345 - #> 2e_1345 - 4e_2345 - 20e_16 + 36e_36 - 22e_46 - 10e_1246 - 24e_1346 - 18e_2346 + #> 4e_256 - 2e_456 - 1e_12456 + 3e_23456  # Following from Ablamowicz and Fauser (see vignette): x <- clifford(list(1:3, c(1,5,7,8,10)), c(4,-10)) + 2 y <- clifford(list(c(1,2,3,7), c(1,5,6,8), c(1,4,6,7)), c(4,1,-3)) - 1 x*y # signature irrelevant #> Element of a Clifford algebra, equal to #> - 2 - 4e_123 - 16e_7 + 8e_1237 - 6e_1467 - 12e_23467 + 2e_1568 + 4e_23568 + #> 10e_6710 - 40e_235810 - 30e_456810 + 10e_157810"},{"path":"https://robinhankin.github.io/clifford/reference/clifford.html","id":null,"dir":"Reference","previous_headings":"","what":"Create, coerce, and test for clifford objects — clifford","title":"Create, coerce, and test for clifford objects — clifford","text":"object class clifford member Clifford algebra. objects may added multiplied, various applications physics mathematics.","code":""},{"path":"https://robinhankin.github.io/clifford/reference/clifford.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create, coerce, and test for clifford objects — clifford","text":"","code":"clifford(terms, coeffs=1) is_ok_clifford(terms, coeffs) as.clifford(x) is.clifford(x) nbits(x) nterms(x) # S3 method for class 'clifford' dim(x)"},{"path":"https://robinhankin.github.io/clifford/reference/clifford.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create, coerce, and test for clifford objects — clifford","text":"terms list integer vectors strictly increasing     entries corresponding basis vectors underlying vector     space coeffs Numeric vector coefficients x Object class clifford","code":""},{"path":"https://robinhankin.github.io/clifford/reference/clifford.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Create, coerce, and test for clifford objects — clifford","text":"Function clifford() formal creation mechanism     clifford objects.  coeffs length 1,     recycled (even terms empty, case     zero Clifford object returned).  Argument terms passed     list_modifier(), zero entry interpreted     numeric(0) Function .clifford() much user-friendly     attempts coerce range input arguments clifford form Function nbits() returns number bits required     low-level C routines store terms (largest     entry list terms).  scalar, zero     zero clifford object (currently) returns zero well although     case made NULL Function nterms() returns number terms     expression Function is_ok_clifford() helper function checks     consistency arguments","code":""},{"path":"https://robinhankin.github.io/clifford/reference/clifford.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Create, coerce, and test for clifford objects — clifford","text":"Snygg 2012.  “new approach differential geometry using   Clifford's geometric algebra”.  Birkhauser; Springer Science+Business.","code":""},{"path":"https://robinhankin.github.io/clifford/reference/clifford.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Create, coerce, and test for clifford objects — clifford","text":"Robin K. S. Hankin","code":""},{"path":[]},{"path":"https://robinhankin.github.io/clifford/reference/clifford.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create, coerce, and test for clifford objects — clifford","text":"","code":"(x <- clifford(list(1,2,1:4),1:3))   # Formal creation method #> Element of a Clifford algebra, equal to #> + 1e_1 + 2e_2 + 3e_1234 (y <- as.1vector(4:2)) #> Element of a Clifford algebra, equal to #> + 4e_1 + 3e_2 + 2e_3 (z <- rcliff(include.fewer=TRUE)) #> Element of a Clifford algebra, equal to #> + 6 - 3e_3 - 8e_25 + 2e_125 + 9e_45 + 6e_2345 - 6e_6 + 4e_2346 + 8e_456 + #> 1e_1456  terms(x+100) #> A disord object with hash 44041cf8cc66f11ef3ad34a2b8596d11d2abe80a and elements #> [[1]] #> integer(0) #>  #> [[2]] #> [1] 1 #>  #> [[3]] #> [1] 2 #>  #> [[4]] #> [1] 1 2 3 4 #>  #> (in some order) coeffs(z) #> A disord object with hash eab31f0bdabf8c45bd98dfa9fadfed85c1a59067 and elements #>  [1]  6 -3 -8  2  9  6 -6  4  8  1 #> (in some order)  ## Clifford objects may be added and multiplied:  x + y #> Element of a Clifford algebra, equal to #> + 5e_1 + 5e_2 + 2e_3 + 3e_1234 x*y #> Element of a Clifford algebra, equal to #> + 10 - 5e_12 + 2e_13 + 4e_23 - 6e_124 + 9e_134 - 12e_234"},{"path":"https://robinhankin.github.io/clifford/reference/const.html","id":null,"dir":"Reference","previous_headings":"","what":"The constant term of a Clifford object — const","title":"The constant term of a Clifford object — const","text":"Get set constant term clifford object.","code":""},{"path":"https://robinhankin.github.io/clifford/reference/const.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"The constant term of a Clifford object — const","text":"","code":"const(C,drop=TRUE) is.real(C) # S3 method for class 'clifford' const(x) <- value"},{"path":"https://robinhankin.github.io/clifford/reference/const.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"The constant term of a Clifford object — const","text":"C, x Clifford object value Replacement value drop Boolean, default TRUE meaning return     constant coerced numeric, FALSE meaning return     (constant) Clifford object","code":""},{"path":"https://robinhankin.github.io/clifford/reference/const.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"The constant term of a Clifford object — const","text":"Extractor method specific terms.  Function const() returns constant element Clifford object.  Note const(C) returns grade(C,0), faster.  C numeric vector, first element returned: elements silently discarded, may change future. R idiom const<-() slightly awkward: reason simply return(x-const(x)+value) return(x+value-const(x)) ensure numerical accuracy; see examples.","code":"> body(`const<-.clifford`) {   stopifnot(length(value) == 1)   x <- x - const(x)   return(x + value) }"},{"path":"https://robinhankin.github.io/clifford/reference/const.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"The constant term of a Clifford object — const","text":"Robin K. S. Hankin","code":""},{"path":[]},{"path":"https://robinhankin.github.io/clifford/reference/const.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"The constant term of a Clifford object — const","text":"","code":"X <- clifford(list(1,1:2,1:3,3:5), 6:9) X #> Element of a Clifford algebra, equal to #> + 6e_1 + 7e_12 + 8e_123 + 9e_345 X <- X + 1e300 X #> Element of a Clifford algebra, equal to #> + 1e+300 + 6e_1 + 7e_12 + 8e_123 + 9e_345  const(X) # should be 1e300 #> [1] 1e+300  const(X) <- 0.6 const(X) # should be 0.6, no numerical error #> [1] 0.6  # compare naive approach:  X <- clifford(list(1,1:2,1:3,3:5), 6:9) + 1e300 X + 0.6 - const(X)  # constant gets lost in the numerics #> Element of a Clifford algebra, equal to #> + 6e_1 + 7e_12 + 8e_123 + 9e_345  X <- clifford(list(1,1:2,1:3,3:5), 6:9) + 1e-300 X - const(X) + 0.6  # answer correct by virtue of left-associativity #> Element of a Clifford algebra, equal to #> + 0.6 + 6e_1 + 7e_12 + 8e_123 + 9e_345   x <- 2+rcliff(d=3, g=3) jj <- x*cliffconj(x) is.real(jj*rev(jj))   # should be TRUE #> [1] TRUE"},{"path":"https://robinhankin.github.io/clifford/reference/dot.html","id":null,"dir":"Reference","previous_headings":"","what":"Class “dot” — dot-class","title":"Class “dot” — dot-class","text":"dot object defined idiom like .[x,y] returns   commutator, , (x*y-y*x)/2.  factor 2 ensures   .[x,y] == x %X% y. dot object generated running script inst/dot.Rmd,   includes discussion technical documentation,   creates file dot.rda resides data/   directory.","code":""},{"path":"https://robinhankin.github.io/clifford/reference/dot.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Class “dot” — dot-class","text":"x Object class , j elements commute ... arguments dot_error(), currently ignored","code":""},{"path":"https://robinhankin.github.io/clifford/reference/dot.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Class “dot” — dot-class","text":"Always returns object class xy.","code":""},{"path":"https://robinhankin.github.io/clifford/reference/dot.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Class “dot” — dot-class","text":"Robin K. S. Hankin","code":""},{"path":"https://robinhankin.github.io/clifford/reference/dot.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Class “dot” — dot-class","text":"","code":"x <- rcliff() y <- rcliff() z <- rcliff()  .[x,.[y,z]] + .[y,.[z,x]] + .[z,.[x,y]]  # Jacobi identity #> Element of a Clifford algebra, equal to #> the zero clifford element (0)"},{"path":"https://robinhankin.github.io/clifford/reference/drop.html","id":null,"dir":"Reference","previous_headings":"","what":"Drop redundant information — drop","title":"Drop redundant information — drop","text":"Coerce scalar Clifford objects numeric","code":""},{"path":"https://robinhankin.github.io/clifford/reference/drop.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Drop redundant information — drop","text":"","code":"drop(x) drop_clifford(x)"},{"path":"https://robinhankin.github.io/clifford/reference/drop.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Drop redundant information — drop","text":"x Clifford object","code":""},{"path":"https://robinhankin.github.io/clifford/reference/drop.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Drop redundant information — drop","text":"argument pure scalar clifford object, pseudoscalar,   coerce numeric.  Scalar pseudoscalar clifford objects   coerced unnamed numeric vector (length 1).  Checking   pseudoscalar requires option maxdim set. Function drop() generic, dispatching helper function   drop_clifford() clifford objects.  logic   drop_clifford() prevents .pseudoscalar() called   maxdim NULL.","code":""},{"path":"https://robinhankin.github.io/clifford/reference/drop.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Drop redundant information — drop","text":"Robin K. S. Hankin","code":""},{"path":[]},{"path":"https://robinhankin.github.io/clifford/reference/drop.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Drop redundant information — drop","text":"Many functions package take drop argument   , TRUE, means function returns   dropped value.","code":""},{"path":"https://robinhankin.github.io/clifford/reference/drop.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Drop redundant information — drop","text":"","code":"drop(as.clifford(5)) #> [1] 5  const(rcliff()) #> [1] 6 const(rcliff(),drop=FALSE) #> Element of a Clifford algebra, equal to #> scalar ( 7 )"},{"path":"https://robinhankin.github.io/clifford/reference/even.html","id":null,"dir":"Reference","previous_headings":"","what":"Even and odd clifford objects — even","title":"Even and odd clifford objects — even","text":"clifford object even every term even grade, odd every term odd grade. Functions .even() .odd() test clifford object evenness oddness. Functions evenpart() oddpart() extract even odd terms clifford object, write \\(A_+\\) \\(A_-\\) respectively; \\(=A_+ + A_-\\)","code":""},{"path":"https://robinhankin.github.io/clifford/reference/even.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Even and odd clifford objects — even","text":"","code":"is.even(C) is.odd(C) evenpart(C) oddpart(C)"},{"path":"https://robinhankin.github.io/clifford/reference/even.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Even and odd clifford objects — even","text":"C Clifford object","code":""},{"path":"https://robinhankin.github.io/clifford/reference/even.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Even and odd clifford objects — even","text":"Robin K. S. Hankin","code":""},{"path":[]},{"path":"https://robinhankin.github.io/clifford/reference/even.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Even and odd clifford objects — even","text":"","code":"A <- rcliff() A == evenpart(A) + oddpart(A) # should be true #> [1] TRUE"},{"path":"https://robinhankin.github.io/clifford/reference/grade.html","id":null,"dir":"Reference","previous_headings":"","what":"The grade of a clifford object — grade","title":"The grade of a clifford object — grade","text":"grade term number basis vectors .","code":""},{"path":"https://robinhankin.github.io/clifford/reference/grade.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"The grade of a clifford object — grade","text":"","code":"grade(C, n, drop=TRUE) grade(C, n) <- value grades(x) gradesplus(x) gradesminus(x) gradeszero(x)"},{"path":"https://robinhankin.github.io/clifford/reference/grade.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"The grade of a clifford object — grade","text":"C, x Clifford object n Integer vector specifying grades extract value Replacement value, numeric vector drop Boolean, default TRUE meaning coerce     constant Clifford object numeric, FALSE meaning     ","code":""},{"path":"https://robinhankin.github.io/clifford/reference/grade.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"The grade of a clifford object — grade","text":"term single expression Clifford object.  coefficient described basis vectors comprises.  Thus \\(4e_{234}\\) term \\(e_3 + e_5\\) . grade term number basis vectors .  Thus grade \\(e_1\\) 1, grade \\(e_{125}=e_1e_2e_5\\) 3.  grade operator \\(\\left\\langle\\cdot\\right\\rangle_r\\) used extract terms particular grade, $$   =\\left\\langle \\right\\rangle_0 +     \\left\\langle \\right\\rangle_1 +     \\left\\langle \\right\\rangle_2 + \\cdots = \\sum_r\\left\\langle \\right\\rangle_r $$ Clifford object \\(\\).  Thus \\(\\left\\langle \\right\\rangle_r\\) said homogenous grade \\(r\\). Hestenes sometimes writes subscripts specify grades using overbar \\(\\left\\langle \\right\\rangle_{\\overline{r}}\\).  conventional denote zero-grade object \\(\\left\\langle \\right\\rangle_0\\) simply \\(\\left\\langle \\right\\rangle\\). $$ \\left\\langle +B\\right\\rangle_r=\\left\\langle \\right\\rangle_r + \\left\\langle B\\right\\rangle_r\\qquad \\left\\langle\\lambda \\right\\rangle_r=\\lambda\\left\\langle \\right\\rangle_r\\qquad \\left\\langle\\left\\langle \\right\\rangle_r\\right\\rangle_s=\\left\\langle \\right\\rangle_r\\delta_{rs}. $$ Function grades() returns (unordered) vector specifying grades constituent terms.  Function grades<-() allows idiom grade(x,1:2) <- 7 operate expected [set coefficients terms grades 1 2 value 7]. Function gradesplus() returns counting basis vectors square \\(+1\\), gradesminus() counts basis vectors square \\(-1\\).  Function signature() controls basis vectors square \\(+1\\) \\(-1\\). Perwass, page 57, given bilinear form $$\\left\\langle{\\mathbf x},{\\mathbf x}\\right\\rangle=x_1^2+x_2^2+\\cdots   +x_p^2-x_{p+1}^2-\\cdots -x_{p+q}^2 $$ basis blade \\(e_\\mathbb{}\\) \\(\\subseteq\\left\\lbrace 1,\\ldots,p+q\\right\\rbrace\\), $$   \\mathrm{gr}(e_A) = \\left|\\left\\lbrace \\\\colon   1\\leqslant \\leqslant p+q\\right\\rbrace\\right| $$ $$   \\mathrm{gr}_{+}(e_A) = \\left|\\left\\lbrace \\\\colon   1\\leqslant \\leqslant p\\right\\rbrace\\right| $$ $$   \\mathrm{gr}_{-}(e_A) = \\left|\\left\\lbrace \\\\colon   p < \\leq p+q\\right\\rbrace\\right| $$ Function gradeszero() counts basis vectors squaring zero (seen anywhere else, logical suggestion). signature zero, Clifford algebra reduces Grassmann algebra products match wedge product exterior calculus.  case, functions gradesplus() gradesminus() return NA. Function grade(C,n) returns clifford object just elements grade g, g %% n. Idiom like grade(C,r) <- value, r non-negative integer (vector non-negative integers) behave expected. two distinct cases: firstly, value length-one numeric vector; secondly, value clifford object: Firstly, grade(C,r) <- value value length-one numeric vector.  changes coefficient grade-r terms value.  Note disordR discipline must respected, value length exceeding one, disordR consistency error might raised. Secondly, grade(C,r) <- value value clifford object.  operate expected: replace grade-r components C value.  value grade component r, “grade mismatch” error returned.  Thus, grade-r components C may modified construction.  semi vectorised: r vector, interpreted set grades replace. zero grade term, grade(C,0), given naturally const(C). Function c_grade() helper function documented Ops.clifford.Rd.","code":""},{"path":"https://robinhankin.github.io/clifford/reference/grade.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"The grade of a clifford object — grade","text":"Robin K. S. Hankin","code":""},{"path":"https://robinhankin.github.io/clifford/reference/grade.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"The grade of a clifford object — grade","text":"C code, “term” slightly different meaning,   referring vectors without associated coefficient.","code":""},{"path":[]},{"path":"https://robinhankin.github.io/clifford/reference/grade.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"The grade of a clifford object — grade","text":"C. Perwass 2009. “Geometric algebra applications     engineering”.  Springer.","code":""},{"path":"https://robinhankin.github.io/clifford/reference/grade.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"The grade of a clifford object — grade","text":"","code":"a <- clifford(sapply(seq_len(7),seq_len),seq_len(7)) a #> Element of a Clifford algebra, equal to #> + 1e_1 + 2e_12 + 3e_123 + 4e_1234 + 5e_12345 + 6e_123456 + 7e_1234567 grades(a) #> A disord object with hash 185ca524fb71fa2ae28566b137978e475c1aa00f and elements #> [1] 1 2 3 4 5 6 7 #> (in some order) grade(a,5) #> Element of a Clifford algebra, equal to #> + 5e_12345   a <- clifford(list(0,3,7,1:2,2:3,3:4,1:3,1:4),1:8) b <- clifford(list(4,1:2,2:3),c(101,102,103))  grade(a,1) <- 13*e(6) grade(a,2) <- grade(b,2) grade(a,0:2) <- grade(b,0:2)*7   signature(2,2) x <- rcliff() drop(gradesplus(x) + gradesminus(x) + gradeszero(x) - grades(x)) #>  [1] 0 0 0 0 0 0 0 0 0 0  a <- rcliff() a == Reduce(`+`,sapply(unique(grades(a)),function(g){grade(a,g)})) #> [1] TRUE"},{"path":"https://robinhankin.github.io/clifford/reference/homog.html","id":null,"dir":"Reference","previous_headings":"","what":"Homogenous Clifford objects — homog","title":"Homogenous Clifford objects — homog","text":"clifford object homogenous terms grade.  scalar (including zero clifford object) considered homogenous.  ensures .homog(grade(C,n)) always returns TRUE.","code":""},{"path":"https://robinhankin.github.io/clifford/reference/homog.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Homogenous Clifford objects — homog","text":"","code":"is.homog(C)"},{"path":"https://robinhankin.github.io/clifford/reference/homog.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Homogenous Clifford objects — homog","text":"C Object class clifford","code":""},{"path":"https://robinhankin.github.io/clifford/reference/homog.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Homogenous Clifford objects — homog","text":"Nonzero homogenous clifford objects multiplicative inverse.","code":""},{"path":"https://robinhankin.github.io/clifford/reference/homog.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Homogenous Clifford objects — homog","text":"Robin K. S. Hankin","code":""},{"path":"https://robinhankin.github.io/clifford/reference/homog.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Homogenous Clifford objects — homog","text":"","code":"is.homog(rcliff()) #> [1] FALSE is.homog(rcliff(include.fewer=FALSE)) #> [1] TRUE"},{"path":"https://robinhankin.github.io/clifford/reference/horner.html","id":null,"dir":"Reference","previous_headings":"","what":"Horner's method — horner","title":"Horner's method — horner","text":"Horner's method Clifford objects","code":""},{"path":"https://robinhankin.github.io/clifford/reference/horner.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Horner's method — horner","text":"","code":"horner(P, v)"},{"path":"https://robinhankin.github.io/clifford/reference/horner.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Horner's method — horner","text":"P Clifford object v Numeric vector coefficients","code":""},{"path":"https://robinhankin.github.io/clifford/reference/horner.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Horner's method — horner","text":"Given polynomial $$p(x) = a_0 +a_1+a_2x^2+\\cdots + a_nx^n$$ possible express \\(p(x)\\) algebraically equivalent   form $$p(x) = a_0 + x\\left(a_1+x\\left(a_2+\\cdots + x\\left(a_{n-1} +xa_n \\right)\\cdots\\right)\\right)$$ much efficient evaluation, requires \\(n\\) multiplications \\(n\\) additions, optimal.  output horner() depends signature().","code":""},{"path":"https://robinhankin.github.io/clifford/reference/horner.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Horner's method — horner","text":"Robin K. S. Hankin","code":""},{"path":"https://robinhankin.github.io/clifford/reference/horner.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Horner's method — horner","text":"Horner's method cool Clifford objects   (e.g.) multivariate polynomials freealg objects.    powers Clifford objects get complicated   power increases.","code":""},{"path":"https://robinhankin.github.io/clifford/reference/horner.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Horner's method — horner","text":"","code":"horner(1 + e(1:3) + e(2:3), 1:6) #> Element of a Clifford algebra, equal to #> + 511 + 490e_1 + 502e_23 + 502e_123  rcliff() |> horner(1:4) #> Element of a Clifford algebra, equal to #> + 4960 - 1364e_1 - 4774e_13 - 5370e_5 - 560e_35 + 5250e_135 + 4774e_16 + #> 5530e_26 - 1500e_126 + 5250e_1236 - 4424e_46 + 1200e_146 - 3222e_246 + #> 4200e_1346 + 336e_2346 - 3150e_12346 + 1840e_56 - 462e_156 + 8046e_256 - #> 896e_1356 - 448e_2356 + 8400e_12356 - 3000e_456 + 3360e_13456"},{"path":"https://robinhankin.github.io/clifford/reference/involution.html","id":null,"dir":"Reference","previous_headings":"","what":"Clifford involutions — involution","title":"Clifford involutions — involution","text":"involution function inverse,   equivalently \\(f(f(x))=x\\).  several important   involutions Clifford objects; commute past grade operator   \\(f(\\left\\langle \\right\\rangle_r)=\\left\\langle   f()\\right\\rangle_r\\) linear: \\(f(\\alpha +\\beta   B)=\\alpha f()+\\beta f(B)\\). dual documented convenience, even though   involution (applying dual four times   identity).  reverse \\(^\\sim\\) given     rev() (Perwass Dorst use tilde,     \\(\\tilde{}\\) \\(^\\sim\\).  However,     Hestenes Chisholm use dagger,     \\(^\\dagger\\).  page uses Perwass's notation).     reverse term written product basis vectors     simply product basis vectors written reverse     order.  changes sign term number basis     vectors 2 3 (modulo 4).  Thus, example,     \\(\\left(e_1e_2e_3\\right)^\\sim=e_3e_2e_1=-e_1e_2e_3\\)         \\(\\left(e_1e_2e_3e_4\\right)^\\sim=e_4e_3e_2e_1=+e_1e_2e_3e_4\\).     Formally, \\(X=e_{i_1}\\ldots e_{i_k}\\),     \\(\\tilde{X}=e_{i_k}\\ldots e_{i_1}\\). $$\\left\\langle       ^\\sim\\right\\rangle_r=\\widetilde{\\left\\langle \t\\right\\rangle_r}=(-1)^{r(r-1)/2}\\left\\langle \\right\\rangle_r     $$ Perwass shows \\(\\left\\langle       AB\\right\\rangle_r=(-1)^{r(r-1)/2}\\left\\langle\\tilde{B}\\tilde{}\\right\\rangle_r     \\) Conjugate \\(^\\dagger\\) given     Conj() (use Perwass's notation, def 2.9 p59).      depends signature Clifford algebra; see     grade.Rd notation.  Given basis blade     \\(e_\\mathbb{}\\) \\(\\mathbb{}\\subseteq\\left\\lbrace     1,\\ldots,p+q\\right\\rbrace\\),     \\(e_\\mathbb{}^\\dagger = (-1)^m {e_\\mathbb{}}^\\sim\\),     \\(m=\\mathrm{gr}_{-}(\\mathbb{})\\).  Alternatively,     might say $$\\left(\\left\\langle     \\right\\rangle_r\\right)^\\dagger=(-1)^m(-1)^{r(r-1)/2}\\left\\langle     \\right\\rangle_r $$     \\(m=\\mathrm{gr}_{-}(\\left\\langle \\right\\rangle_r)\\) [NB     changed Perwass's notation]. main (grade) involution grade involution     \\(\\widehat{}\\) given gradeinv().      changes sign term odd grade: $$\\widehat{\\left\\langle \\right\\rangle_r} =(-1)^r\\left\\langle       \\right\\rangle_r$$ (see Perwass Hestenes; notation follows Hitzer     Sangwine).  special case grade negation. grade \\(r\\)-negation     \\(A_{\\overline{r}}\\) given neg().      changes sign grade \\(r\\) component \\(\\).      formally defined \\(-2\\left\\langle     \\right\\rangle_r\\) function neg() uses     efficient method.  possible negate terms specified     grades, example might \\(\\left\\langle     \\right\\rangle_{\\overline{\\left\\lbrace 1,2,5\\right\\rbrace}} =     -2\\left( \\left\\langle \\right\\rangle_1 +\\left\\langle     \\right\\rangle_2+\\left\\langle \\right\\rangle_5\\right)\\)     R idiom neg(,c(1,2,5)).  Note Hestenes     uses “\\(A_{\\overline{r}}\\)” mean     \\(\\left\\langle \\right\\rangle_r\\). Clifford conjugate \\(\\overline{}\\)     given cliffconj().  distinct conjugation     \\(^\\dagger\\), defined Hitzer Sangwine $$\\overline{\\left\\langle \\right\\rangle_r} =       (-1)^{r(r+1)/2}\\left\\langle \\right\\rangle_r.$$ dual \\(C^*\\) clifford object \\(C\\)     given dual(C,n); argument n dimension     underlying vector space.  Perwass gives     \\(C^*=CI^{-1}\\) \\(=e_1e_2\\ldots e_n\\) unit pseudoscalar     [note Hestenes uses \\(\\) mean something different].     dual sensitive signature Clifford algebra     dimension underlying vector space.","code":""},{"path":"https://robinhankin.github.io/clifford/reference/involution.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Clifford involutions — involution","text":"","code":"# S3 method for class 'clifford' rev(x) # S3 method for class 'clifford' Conj(z) cliffconj(z) neg(C,n) gradeinv(C)"},{"path":"https://robinhankin.github.io/clifford/reference/involution.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Clifford involutions — involution","text":"C,x,z Clifford object n Integer vector specifying grades negated neg()","code":""},{"path":"https://robinhankin.github.io/clifford/reference/involution.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Clifford involutions — involution","text":"Robin K. S. Hankin","code":""},{"path":[]},{"path":"https://robinhankin.github.io/clifford/reference/involution.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Clifford involutions — involution","text":"","code":"x <- rcliff() x #> Element of a Clifford algebra, equal to #> + 4 - 1e_12 - 2e_3 + 2e_1234 - 8e_5 - 5e_1235 - 3e_2345 + 3e_16 + 1e_26 rev(x) #> Element of a Clifford algebra, equal to #> + 4 + 1e_12 - 2e_3 + 2e_1234 - 8e_5 - 5e_1235 - 3e_2345 - 3e_16 - 1e_26   A <- rblade(g=3) B <- rblade(g=4) rev(A %^% B) == rev(B) %^% rev(A)  # should be TRUE #> [1] TRUE rev(A * B) == rev(B) * rev(A)          # should be TRUE #> [1] TRUE  options(maxdim=8) a <- rcliff(d=8) dual(dual(dual(dual(a,8),8),8),8) == a # should be TRUE #> [1] FALSE options(maxdim=NULL) # restore default"},{"path":"https://robinhankin.github.io/clifford/reference/lowlevel.html","id":null,"dir":"Reference","previous_headings":"","what":"Low-level helper functions for clifford objects — lowlevel","title":"Low-level helper functions for clifford objects — lowlevel","text":"Helper functions clifford objects, written C using   STL map class.","code":""},{"path":"https://robinhankin.github.io/clifford/reference/lowlevel.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Low-level helper functions for clifford objects — lowlevel","text":"","code":"c_identity(L, p, m) c_grade(L, c, m, n) c_add(L1, c1, L2, c2, m) c_multiply(L1, c1, L2, c2, m, sig) c_power(L, c, m, p, sig) c_equal(L1, c1, L2, c2, m) c_overwrite(L1, c1, L2, c2, m) c_cartan(L, c, m, n) c_cartan_inverse(L, c, m, n)"},{"path":"https://robinhankin.github.io/clifford/reference/lowlevel.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Low-level helper functions for clifford objects — lowlevel","text":"L, L1, L2 Lists terms c1, c2, c Numeric vectors coefficients m Maximum entry terms n Grade extract p Integer power sig Two positive integers, \\(p\\) \\(q\\),     representing number \\(+1\\) \\(-1\\) terms     main diagonal quadratic form","code":""},{"path":"https://robinhankin.github.io/clifford/reference/lowlevel.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Low-level helper functions for clifford objects — lowlevel","text":"functions documented low-level helper functions wrap   C code.  called functions like   clifford_plus_clifford(), called   binary operators documented Ops.clifford.Rd.  functions   documented really intended day--day use. Function c_identity() checks list terms L   length vector coefficients p; , error   given.  Note R function clifford() recycle   coefficient vector length 1,   clifford(list(1,1:2),7) works expected (  c_identity(list(1,1:2),7,2) throw error). Function clifford_inverse() problematic nonnull blades   always inverse; function .blade() yet   implemented.  Blades (including null blades) pseudoinverse,   implemented yet either.","code":""},{"path":"https://robinhankin.github.io/clifford/reference/lowlevel.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Low-level helper functions for clifford objects — lowlevel","text":"high-level functions documented return object class   clifford.  use low-level functions.","code":""},{"path":"https://robinhankin.github.io/clifford/reference/lowlevel.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Low-level helper functions for clifford objects — lowlevel","text":"Robin K. S. Hankin","code":""},{"path":[]},{"path":"https://robinhankin.github.io/clifford/reference/magnitude.html","id":null,"dir":"Reference","previous_headings":"","what":"Magnitude of a clifford object — magnitude","title":"Magnitude of a clifford object — magnitude","text":"Following Perwass, magnitude multivector defined $$\\left|\\left|\\right|\\right| = \\sqrt{\\ast }$$ \\(\\ast \\) denotes Euclidean scalar product   eucprod().  Recall Euclidean scalar product never   negative (function body sqrt(abs(eucprod(z)));   abs() needed avoid numerical roundoff errors   eucprod() giving negative value).","code":""},{"path":"https://robinhankin.github.io/clifford/reference/magnitude.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Magnitude of a clifford object — magnitude","text":"","code":"# S3 method for class 'clifford' Mod(z)"},{"path":"https://robinhankin.github.io/clifford/reference/magnitude.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Magnitude of a clifford object — magnitude","text":"z Clifford objects","code":""},{"path":"https://robinhankin.github.io/clifford/reference/magnitude.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Magnitude of a clifford object — magnitude","text":"Robin K. S. Hankin","code":""},{"path":"https://robinhankin.github.io/clifford/reference/magnitude.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Magnitude of a clifford object — magnitude","text":"want square, \\(\\left|\\left|\\right|\\right|^2\\) \\(\\left|\\left|\\right|\\right|\\), faster accurate use eucprod(), avoids needless square root. nice example scalar product rcliff.Rd.","code":""},{"path":[]},{"path":"https://robinhankin.github.io/clifford/reference/magnitude.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Magnitude of a clifford object — magnitude","text":"","code":"Mod(rcliff()) #> [1] 12.24745   # Perwass, p68, asserts that if A is a k-blade, then (in his notation) # AA == A*A.  # In package idiom, A*A == A %star% A:  A <- rcliff()           Mod(A*A - A %star% A)  # meh #> [1] 82.19489  A <- rblade() Mod(A*A - A %star% A)  # should be small #> [1] 0"},{"path":"https://robinhankin.github.io/clifford/reference/minus.html","id":null,"dir":"Reference","previous_headings":"","what":"Take the negative of a vector — minus","title":"Take the negative of a vector — minus","text":"simple function takes negative vector, idiom coeffs(z)[gradesminus(z)%%2 != 0] %<>% minus works intended (taken Conj.clifford()).","code":""},{"path":"https://robinhankin.github.io/clifford/reference/minus.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Take the negative of a vector — minus","text":"","code":"minus(x)"},{"path":"https://robinhankin.github.io/clifford/reference/minus.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Take the negative of a vector — minus","text":"Returns vector disord","code":""},{"path":"https://robinhankin.github.io/clifford/reference/minus.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Take the negative of a vector — minus","text":"x vector disord object","code":""},{"path":"https://robinhankin.github.io/clifford/reference/minus.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Take the negative of a vector — minus","text":"Robin K. S. Hankin","code":""},{"path":"https://robinhankin.github.io/clifford/reference/numeric_to_clifford.html","id":null,"dir":"Reference","previous_headings":"","what":"Coercion from numeric to Clifford form — numeric_to_clifford","title":"Coercion from numeric to Clifford form — numeric_to_clifford","text":"Given numeric value vector, return Clifford algebra element","code":""},{"path":"https://robinhankin.github.io/clifford/reference/numeric_to_clifford.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Coercion from numeric to Clifford form — numeric_to_clifford","text":"","code":"numeric_to_clifford(x) as.1vector(x) is.1vector(x) scalar(x=1) as.scalar(x=1) is.scalar(C) basis(n, x=1) e(n, x=1)"},{"path":"https://robinhankin.github.io/clifford/reference/numeric_to_clifford.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Coercion from numeric to Clifford form — numeric_to_clifford","text":"x Numeric vector n Integer specifying dimensionality underlying vector space C Object possibly class Clifford","code":""},{"path":"https://robinhankin.github.io/clifford/reference/numeric_to_clifford.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Coercion from numeric to Clifford form — numeric_to_clifford","text":"Function .scalar() takes length-one numeric vector   returns Clifford scalar value (extract scalar   component multivector, use const()). Function .scalar() synonym .real()   documented const.Rd. Function .1vector() takes numeric vector returns   linear sum length-one blades coefficients given x;   function .1vector() returns TRUE every term   grade 1. Function numeric_to_vector() dispatches either   .scalar() length-one vectors .1vector()   length greater one. Function basis() returns wedge product basis vectors;   function e() synonym.  special dispensation   zero, e(0) returns Clifford scalar 1. Function antivector() arguably described   actually documented antivector.Rd.","code":""},{"path":"https://robinhankin.github.io/clifford/reference/numeric_to_clifford.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Coercion from numeric to Clifford form — numeric_to_clifford","text":"Robin K. S. Hankin","code":""},{"path":[]},{"path":"https://robinhankin.github.io/clifford/reference/numeric_to_clifford.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Coercion from numeric to Clifford form — numeric_to_clifford","text":"","code":"as.scalar(6) #> Element of a Clifford algebra, equal to #> scalar ( 6 ) as.1vector(1:8) #> Element of a Clifford algebra, equal to #> + 1e_1 + 2e_2 + 3e_3 + 4e_4 + 5e_5 + 6e_6 + 7e_7 + 8e_8  e(5:8) #> Element of a Clifford algebra, equal to #> + 1e_5678  Reduce(`+`,sapply(seq_len(7),function(n){e(seq_len(n))},simplify=FALSE)) #> Element of a Clifford algebra, equal to #> + 1e_1 + 1e_12 + 1e_123 + 1e_1234 + 1e_12345 + 1e_123456 + 1e_1234567"},{"path":"https://robinhankin.github.io/clifford/reference/print.html","id":null,"dir":"Reference","previous_headings":"","what":"Print clifford objects — print","title":"Print clifford objects — print","text":"Print methods Clifford algebra","code":""},{"path":"https://robinhankin.github.io/clifford/reference/print.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print clifford objects — print","text":"","code":"# S3 method for class 'clifford' print(x,...) # S3 method for class 'clifford' as.character(x,...) catterm(a)"},{"path":"https://robinhankin.github.io/clifford/reference/print.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print clifford objects — print","text":"x Object class clifford print method ... arguments, currently ignored Integer vector representing term","code":""},{"path":"https://robinhankin.github.io/clifford/reference/print.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Print clifford objects — print","text":"Robin K. S. Hankin","code":""},{"path":"https://robinhankin.github.io/clifford/reference/print.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Print clifford objects — print","text":"print method change internal representation clifford object, two-element list, first list integer vectors representing terms, second numeric vector coefficients.  print method special dispensation zero clifford object. print method sensitive value options separate basissep.  option separate FALSE (default), method prints basis blades compact form, “e_134”.  indices basis vectors separated value option basissep usually NULL; \\(n>9\\), setting option basissep comma (“,”) might look good print e_10,11,12 instead e_101112: option separate TRUE, method prints basis vectors separately, e10 e11 e12: Function catterm() low-level helper function, used print method, coercion character, also function getcoeffs() set names output.  takes integer vector like c(1,5,6) returns representation corresponding basis blade, case “e_156”.  Function catterm() options basissep separate processed.  Special dispensation needed length-zero vectors, empty string returned.  needed ensure constant term (basis blade numeric(0)) treated appropriately.  See also list_modifier() deals issue. prompt can changed show signature documented signature. Experimental bespoke print method print_clifford_quaternion() print_clifford_pauli() included.  executed option clifford_print_special quaternion; NULL, print_clifford_default() used.  straightforward add bespoke print methods needed (modify print.clifford()).","code":"options(\"basissep\" = \",\") options(\"separate\" = TRUE)"},{"path":[]},{"path":"https://robinhankin.github.io/clifford/reference/print.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Print clifford objects — print","text":"","code":"a <- rclifff(9) a   # default print method incomprehensible #> Element of a Clifford algebra, equal to #> + 6 + 5e_12 - 5e_512 + 6e_6791518 - 9e_34691214161719 + 1e_25101214171820 - #> 2e_124510111920 - 6e_6781213151920 - 3e_24578911161920 + 7e_15610111415171920  options(\"separate\" = TRUE) a    # marginally better #> Element of a Clifford algebra, equal to #> + 6 + 5e12 - 5e5 e12 + 6e6 e7 e9 e15 e18 - 9e3 e4 e6 e9 e12 e14 e16 e17 e19 + #> 1e2 e5 e10 e12 e14 e17 e18 e20 - 2e1 e2 e4 e5 e10 e11 e19 e20 - 6e6 e7 e8 e12 #> e13 e15 e19 e20 - 3e2 e4 e5 e7 e8 e9 e11 e16 e19 e20 + 7e1 e5 e6 e10 e11 e14 #> e15 e17 e19 e20   options(\"separate\" = FALSE) options(basissep=\",\") a    #  clearer; YMMV #> Element of a Clifford algebra, equal to #> + 6 + 5e_12 - 5e_5,12 + 6e_6,7,9,15,18 - 9e_3,4,6,9,12,14,16,17,19 + #> 1e_2,5,10,12,14,17,18,20 - 2e_1,2,4,5,10,11,19,20 - 6e_6,7,8,12,13,15,19,20 - #> 3e_2,4,5,7,8,9,11,16,19,20 + 7e_1,5,6,10,11,14,15,17,19,20  options(basissep = NULL, maxdim=NULL)  # restore default  options(\"maxdim\" = 3) signature(3) a <- clifford(list(0,c(1,2),c(1,3),c(2,3)), 6:9) a #> Element of a Clifford algebra, equal to #> + 6 + 7e_12 + 8e_13 + 9e_23  options(\"clifford_print_special\" = \"quaternion\") a #> A quaternion equal to:  #> +6 -7i -8j -9k  options(\"maxdim\" = NULL) options(\"clifford_print_special\" = NULL) signature(Inf)"},{"path":"https://robinhankin.github.io/clifford/reference/pseudoscalar.html","id":null,"dir":"Reference","previous_headings":"","what":"Coercion from numeric to Clifford form — pseudoscalar","title":"Coercion from numeric to Clifford form — pseudoscalar","text":"Given numeric value vector, return Clifford algebra element","code":""},{"path":"https://robinhankin.github.io/clifford/reference/pseudoscalar.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Coercion from numeric to Clifford form — pseudoscalar","text":"","code":"pseudoscalar() is.pseudoscalar(C)"},{"path":"https://robinhankin.github.io/clifford/reference/pseudoscalar.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Coercion from numeric to Clifford form — pseudoscalar","text":"C Object possibly class Clifford","code":""},{"path":"https://robinhankin.github.io/clifford/reference/pseudoscalar.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Coercion from numeric to Clifford form — pseudoscalar","text":"Function pseudoscalar() returns unit pseudoscalar   dimensionality option(\"maxdim\") function   .pseudoscalar() checks Clifford object   pseudoscalar.  Note functions require maxdim   set; otherwise meaningless. Usually, one set option(maxdim) start session,   together signature.  one might define <-   pseudoscalar() interests compactness legibility.","code":""},{"path":"https://robinhankin.github.io/clifford/reference/pseudoscalar.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Coercion from numeric to Clifford form — pseudoscalar","text":"Robin K. S. Hankin","code":""},{"path":[]},{"path":"https://robinhankin.github.io/clifford/reference/pseudoscalar.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Coercion from numeric to Clifford form — pseudoscalar","text":"","code":"options(maxdim=6) I <- pseudoscalar() is.pseudoscalar(I) #> [1] TRUE options(maxdim=NULL) # restore default"},{"path":"https://robinhankin.github.io/clifford/reference/quaternion.html","id":null,"dir":"Reference","previous_headings":"","what":"Quaternions using Clifford algebras — quaternion","title":"Quaternions using Clifford algebras — quaternion","text":"Converting quaternions Clifford objects part   package functionality short discussion included   inst/quaternion_clifford.Rmd.","code":""},{"path":"https://robinhankin.github.io/clifford/reference/quaternion.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Quaternions using Clifford algebras — quaternion","text":"Given quaternion \\(+bi+cj+dk\\), one may identify \\(\\) \\(-e_{12}\\), \\(j\\) \\(-e_{13}\\), \\(k\\) \\(-e_{23}\\) (constant term course \\(e_0\\)).","code":""},{"path":"https://robinhankin.github.io/clifford/reference/quaternion.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Quaternions using Clifford algebras — quaternion","text":"Robin K. S. Hankin","code":""},{"path":"https://robinhankin.github.io/clifford/reference/quaternion.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Quaternions using Clifford algebras — quaternion","text":"different mapping, quaternions   \\(\\operatorname{Cl}(0,2)\\) given   signature.Rd.","code":""},{"path":[]},{"path":"https://robinhankin.github.io/clifford/reference/rcliff.html","id":null,"dir":"Reference","previous_headings":"","what":"Random clifford objects — rcliff","title":"Random clifford objects — rcliff","text":"Random Clifford algebra elements, intended quick   “get going” examples clifford objects","code":""},{"path":"https://robinhankin.github.io/clifford/reference/rcliff.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Random clifford objects — rcliff","text":"","code":"rcliff(n=9, d=6, g=4, include.fewer=TRUE) rclifff(n=100, d=20, g=10, include.fewer=TRUE) rblade(d=7, g=3)"},{"path":"https://robinhankin.github.io/clifford/reference/rcliff.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Random clifford objects — rcliff","text":"n Number terms d Dimensionality underlying vector space g Maximum grade term include.fewer Boolean, FALSE meaning     return clifford object comprising terms grade g,     default TRUE meaning include terms     grades less g (including term grade zero,     , scalar)","code":""},{"path":"https://robinhankin.github.io/clifford/reference/rcliff.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Random clifford objects — rcliff","text":"Function rcliff() gives quick nontrivial Clifford object,   typically terms range grades (see grade.Rd);   argument include.fewer=FALSE ensures terms   grade.  Function rclifff() returns   complicated object default. Function rblade() gives Clifford object   blade (see term.Rd).  returns wedge product   number 1-vectors, example   \\(\\left(e_1+2e_2\\right)\\wedge\\left(e_1+3e_5\\right)\\). Perwass gives following lemma: Given blades \\(A_{\\langle r\\rangle}, B_{\\langle s\\rangle},     C_{\\langle t\\rangle}\\), $$     \\langle     A_{\\langle r\\rangle}     B_{\\langle s\\rangle}     C_{\\langle t\\rangle}     \\rangle_0     =     \\langle     C_{\\langle t\\rangle}     A_{\\langle r\\rangle}     B_{\\langle s\\rangle}     \\rangle_0   $$ proof notes intermediate step $$     \\langle     A_{\\langle r\\rangle}     B_{\\langle s\\rangle}     \\rangle_t *     C_{\\langle t\\rangle}     =     C_{\\langle t\\rangle} *     \\langle     A_{\\langle r\\rangle}     B_{\\langle s\\rangle}     \\rangle_t     =     \\langle     C_{\\langle t\\rangle}     A_{\\langle r\\rangle}     B_{\\langle s\\rangle}     \\rangle_0.   $$ Package idiom shown examples.","code":""},{"path":"https://robinhankin.github.io/clifford/reference/rcliff.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Random clifford objects — rcliff","text":"Robin K. S. Hankin","code":""},{"path":"https://robinhankin.github.io/clifford/reference/rcliff.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Random clifford objects — rcliff","text":"grade exceeds dimensionality, \\(g>d\\),   result arguably zero; rcliff() returns error.","code":""},{"path":[]},{"path":"https://robinhankin.github.io/clifford/reference/rcliff.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Random clifford objects — rcliff","text":"","code":"rcliff() #> Element of a Clifford algebra, equal to #> + 6 - 3e_2 + 4e_134 - 5e_16 + 8e_36 + 5e_1236 - 1e_256 + 9e_2356 + 6e_3456 rcliff(d=3,g=2) #> Element of a Clifford algebra, equal to #> + 5 + 8e_1 - 3e_2 - 8e_12 + 2e_3 - 1e_13 rcliff(3,10,7) #> Element of a Clifford algebra, equal to #> + 3 - 2e_49 + 1e_1457910 - 3e_1578910 rcliff(3,10,7,include=TRUE) #> Element of a Clifford algebra, equal to #> + 3 + 3e_56 - 1e_234568 - 3e_1569  x1 <- rcliff() x2 <- rcliff() x3 <- rcliff()  x1*(x2*x3) == (x1*x2)*x3  # should be TRUE #> [1] TRUE   rblade() #> Element of a Clifford algebra, equal to #> - 21e_123 - 4e_124 + 1e_134 - 9e_234 - 8e_125 + 2e_135 - 18e_235 + 40e_126 + #> 32e_136 - 15e_236 + 8e_146 - 20e_246 - 13e_346 + 16e_156 - 40e_256 - 26e_356 - #> 22e_127 - 5e_137 - 18e_237 - 2e_147 + 6e_247 + 3e_347 - 4e_157 + 12e_257 + #> 6e_357 - 24e_167 + 50e_267 + 31e_367 - 2e_467 - 4e_567  # We can invert blades easily: a <- rblade() ainv <- rev(a)/scalprod(a)  zap(a*ainv)  # 1 (to numerical precision) #> [1] 1 zap(ainv*a)  # 1 (to numerical precision) #> [1] 1  # Perwass 2009, lemma 3.9:   A <- rblade(d=9, g=4) B <- rblade(d=9, g=5) C <- rblade(d=9, g=6)  grade(A*B*C,0) - grade(C*A*B,0)   # zero to numerical precision #> [1] 0    # Intermediate step  x1 <- grade(A*B,3) %star% C x2 <- C %star% grade(A*B,3) x3 <- grade(C*A*B,0)  max(x1,x2,x3) - min(x1,x2,x3)   # zero to numerical precision #> [1] 0"},{"path":"https://robinhankin.github.io/clifford/reference/signature.html","id":null,"dir":"Reference","previous_headings":"","what":"The signature of the Clifford algebra — signature","title":"The signature of the Clifford algebra — signature","text":"Getting setting signature Clifford algebra","code":""},{"path":"https://robinhankin.github.io/clifford/reference/signature.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"The signature of the Clifford algebra — signature","text":"","code":"signature(p, q=0) is_ok_sig(s) showsig(s) # S3 method for class 'sigobj' print(x, ...)"},{"path":"https://robinhankin.github.io/clifford/reference/signature.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"The signature of the Clifford algebra — signature","text":"s, p, q Integers, specifying number positive elements     diagonal quadratic form, s = c(p, q) x Object class sigobj ... arguments, currently ignored","code":""},{"path":"https://robinhankin.github.io/clifford/reference/signature.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"The signature of the Clifford algebra — signature","text":"signature functionality modelled lorentz package; clifford::signature() operates way lorentz::sol() gets sets speed light.  idea speed light signature Clifford algebra generally set , beginning R session, subsequently change infrequently. Clifford algebras require bilinear form \\(\\left\\langle\\cdot,\\cdot\\right\\rangle\\) \\(\\mathbb{R}^n\\).  \\({\\mathbf x}=\\left(x_1,\\ldots,x_n\\right)\\) define $$\\left\\langle{\\mathbf x},{\\mathbf x}\\right\\rangle=x_1^2+x_2^2+\\cdots   +x_p^2-x_{p+1}^2-\\cdots -x_{p+q}^2 $$ \\(p+q=n\\).  quadratic form vector space denoted \\(\\mathbb{R}^{p,q}\\) say \\((p,q)\\) signature bilinear form \\(\\left\\langle\\cdot,\\cdot\\right\\rangle\\).  gives rise Clifford algebra \\(C_{p,q}\\). signature \\((p,q)\\), $$   e_i e_i =   +1\\, (\\mbox{} 1\\leq \\leq p),               -1\\, (\\mbox{} p+1\\leq \\leq p+q),                0\\, (\\mbox{} >p+q).   $$ Note \\((p,0)\\) corresponds positive-semidefinite quadratic form \\(e_ie_i=+1\\) \\(\\leq p\\) \\(e_ie_i=0\\) \\(> p\\). Similarly, \\((0,q)\\) corresponds negative-semidefinite quadratic form \\(e_ie_i=-1\\) \\(\\leq q\\) \\(e_ie_i=0\\) \\(> q\\). strictly positive-definite quadratic form specified infinite \\(p\\) [case \\(q\\) irrelevant], signature(Inf) implements .  strictly negative-definite quadratic form \\(p=0,q=\\infty\\) signature(0,Inf). specify \\(e_ie_i=0\\) \\(\\), operation reduces wedge product Grassmann algebra.  Package idiom set \\(p=q=0\\) signature(0,0), recommended: use stokes package Grassmann algebras, much efficient uses nicer idiom. Function signature(p,q) returns signature invisibly; setting option show_signature TRUE makes showsig() [called signature()] change default prompt displays signature, much like showSOL lorentz package.  Note changing signature changes prompt immediately (show_signature TRUE), changing option show_signature effect showsig() called. Calling signature() [, arguments] returns object class sigobj elements corresponding \\(p\\) \\(q\\).  special dispensation “infinite” \\(p\\) \\(q\\): sigobj class ensures near-infinite integer .Machine$integer.max printed “Inf” rather , example, “2147483647”. Function is_ok_sig() helper function checks proper signature.  set signature(p,q), technically \\(n>p+q\\) implies \\(e_n^2=0\\), usually interested \\(e_n\\) \\(n>p+q\\) want error. Option maxdim specifies maximum value \\(n\\), default NULL corresponding infinity.  \\(n\\) exceeds maxdim, is_ok_sig() throws error.  Note sometimes fine maxdim > p+q [indeed useful context dual numbers].  option intended super-strict safety measure.","code":"> e(6) Element of a Clifford algebra, equal to + 1e_6 > options(maxdim=5) > e(5) Element of a Clifford algebra, equal to + 1e_5 > e(6) Error in is_ok_clifford(terms, coeffs) : option maxdim exceeded"},{"path":"https://robinhankin.github.io/clifford/reference/signature.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"The signature of the Clifford algebra — signature","text":"Robin K. S. Hankin","code":""},{"path":"https://robinhankin.github.io/clifford/reference/signature.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"The signature of the Clifford algebra — signature","text":"","code":"signature() #> [1] Inf   0  e(1)^2 #> Element of a Clifford algebra, equal to #> scalar ( 1 ) e(2)^2 #> Element of a Clifford algebra, equal to #> scalar ( 1 )  signature(1) e(1)^2 #> Element of a Clifford algebra, equal to #> scalar ( 1 ) e(2)^2   # note sign #> Element of a Clifford algebra, equal to #> the zero clifford element (0)  signature(3, 4) sapply(1:10, function(i){drop(e(i)^2)}) #>  [1]  1  1  1 -1 -1 -1 -1  0  0  0   signature(Inf)   # restore default     # Nice mapping from Cl(0,2) to the quaternions (loading clifford and # onion simultaneously is discouraged):  # library(\"onion\") # signature(0,2) # Q1 <- rquat(1) # Q2 <- rquat(1) # f <- function(H){Re(H) + i(H)*e(1) + j(H)*e(2) + k(H)*e(1:2)} # f(Q1)*f(Q2) - f(Q1*Q2) # zero to numerical precision # signature(Inf)"},{"path":"https://robinhankin.github.io/clifford/reference/summary.html","id":null,"dir":"Reference","previous_headings":"","what":"Summary methods for clifford objects — summary.clifford","title":"Summary methods for clifford objects — summary.clifford","text":"Summary method clifford objects, print method summaries.","code":""},{"path":"https://robinhankin.github.io/clifford/reference/summary.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Summary methods for clifford objects — summary.clifford","text":"","code":"# S3 method for class 'clifford' summary(object, ...) # S3 method for class 'summary.clifford' print(x, ...) first_n_last(x)"},{"path":"https://robinhankin.github.io/clifford/reference/summary.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Summary methods for clifford objects — summary.clifford","text":"object,x Object class clifford ... arguments, currently ignored","code":""},{"path":"https://robinhankin.github.io/clifford/reference/summary.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Summary methods for clifford objects — summary.clifford","text":"Summary clifford object.   Note carefully   “typical terms” implementation specific.  Function   first_n_last() helper function.","code":""},{"path":"https://robinhankin.github.io/clifford/reference/summary.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Summary methods for clifford objects — summary.clifford","text":"Robin K. S. Hankin","code":""},{"path":[]},{"path":"https://robinhankin.github.io/clifford/reference/summary.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Summary methods for clifford objects — summary.clifford","text":"","code":"summary(rcliff()) #> Element of a Clifford algebra  #> Typical terms:  6  ...  + 8e_2356  #> Number of terms: 9  #> Magnitude: 290"},{"path":"https://robinhankin.github.io/clifford/reference/term.html","id":null,"dir":"Reference","previous_headings":"","what":"Deal with terms — term","title":"Deal with terms — term","text":"basis vector, mean one basis vectors underlying vector space \\(R^n\\), , element set \\(\\left\\lbrace e_1,\\ldots,e_n\\right\\rbrace\\).  term wedge product basis vectors (geometric product linearly independent basis vectors), something like \\(e_{12}\\) \\(e_{12569}\\).  Sometimes use word “term” mean wedge product basis vectors together associated coefficient: \\(7e_{12}\\) described term. Perwass: blade outer product number 1-vectors (, equivalently, wedge product linearly independent 1-vectors).  Thus \\(e_{12}=e_1\\wedge e_2\\) \\(e_{12} + e_{13}=e_1\\wedge(e_2+e_3)\\) blades, \\(e_{12} + e_{34}\\) . Function rblade(), documented rcliff.Rd, returns random blade. Function .blade() currently implemented: easy way detect whether Clifford object product 1-vectors.","code":""},{"path":"https://robinhankin.github.io/clifford/reference/term.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Deal with terms — term","text":"","code":"terms(x) is.blade(x) is.basisblade(x)"},{"path":"https://robinhankin.github.io/clifford/reference/term.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Deal with terms — term","text":"x Object class clifford","code":""},{"path":"https://robinhankin.github.io/clifford/reference/term.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Deal with terms — term","text":"Functions terms() coeffs()     extraction methods.  unordered vectors ordering     consistent (extended discussion phenomenon     presented mvp package). Function term() returns clifford object comprises     single term unit coefficient. Function .basisterm() returns TRUE     argument single term, nonzero scalar; zero     clifford object considered basis term.","code":""},{"path":"https://robinhankin.github.io/clifford/reference/term.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Deal with terms — term","text":"C. Perwass. “Geometric algebra applications   engineering”.   Springer, 2009.","code":""},{"path":"https://robinhankin.github.io/clifford/reference/term.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Deal with terms — term","text":"Robin K. S. Hankin","code":""},{"path":[]},{"path":"https://robinhankin.github.io/clifford/reference/term.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Deal with terms — term","text":"","code":"x <- rcliff() terms(x) #> A disord object with hash 7626c66c33b83172f7fd824a9fa20059caa7ca2c and elements #> [[1]] #> integer(0) #>  #> [[2]] #> [1] 1 #>  #> [[3]] #> [1] 2 #>  #> [[4]] #> [1] 4 #>  #> [[5]] #> [1] 3 4 5 #>  #> [[6]] #> [1] 1 3 4 5 #>  #> [[7]] #> [1] 6 #>  #> [[8]] #> [1] 1 2 3 6 #>  #> [[9]] #> [1] 1 3 5 6 #>  #> (in some order)  is.basisblade(x) #> [1] FALSE  a <- as.1vector(1:3) b <- as.1vector(c(0,0,0,12,13))  a %^% b # a blade #> Element of a Clifford algebra, equal to #> + 12e_14 + 24e_24 + 36e_34 + 13e_15 + 26e_25 + 39e_35"},{"path":"https://robinhankin.github.io/clifford/reference/vector.html","id":null,"dir":"Reference","previous_headings":"","what":"Coerce a clifford vector to a numeric vector — as.vector","title":"Coerce a clifford vector to a numeric vector — as.vector","text":"Given clifford object terms grade 1, return   corresponding numeric vector","code":""},{"path":"https://robinhankin.github.io/clifford/reference/vector.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Coerce a clifford vector to a numeric vector — as.vector","text":"","code":"# S3 method for class 'clifford' as.vector(x, mode = \"any\")"},{"path":"https://robinhankin.github.io/clifford/reference/vector.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Coerce a clifford vector to a numeric vector — as.vector","text":"x Object class clifford mode ignored","code":""},{"path":"https://robinhankin.github.io/clifford/reference/vector.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Coerce a clifford vector to a numeric vector — as.vector","text":"Robin K. S. Hankin","code":""},{"path":"https://robinhankin.github.io/clifford/reference/vector.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Coerce a clifford vector to a numeric vector — as.vector","text":"awkward R idiom function terms may stored order; see examples","code":""},{"path":[]},{"path":"https://robinhankin.github.io/clifford/reference/vector.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Coerce a clifford vector to a numeric vector — as.vector","text":"","code":"x <- clifford(list(6,2,9), 1:3) as.vector(x) #> [1] 0 2 0 0 0 1 0 0 3  as.1vector(as.vector(x)) == x  # should be TRUE #> [1] TRUE"},{"path":"https://robinhankin.github.io/clifford/reference/zap.html","id":null,"dir":"Reference","previous_headings":"","what":"Zap small values in a clifford object — zap","title":"Zap small values in a clifford object — zap","text":"Generic version zapsmall()","code":""},{"path":"https://robinhankin.github.io/clifford/reference/zap.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Zap small values in a clifford object — zap","text":"","code":"zap(x, drop=TRUE, digits = getOption(\"digits\"))"},{"path":"https://robinhankin.github.io/clifford/reference/zap.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Zap small values in a clifford object — zap","text":"x Clifford object drop Boolean default TRUE meaning     coerce output numeric drop() digits number digits retain","code":""},{"path":"https://robinhankin.github.io/clifford/reference/zap.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Zap small values in a clifford object — zap","text":"Given clifford object, coefficients close zero   ‘zapped’, .e., replaced ‘0’ much way   base::zapsmall(). function called zapsmall(), dispatch   appropriate base function, figure   S3 (docs singularly unhelpful) gave . Note, function actually changes numeric value, just   print method.","code":""},{"path":"https://robinhankin.github.io/clifford/reference/zap.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Zap small values in a clifford object — zap","text":"Robin K. S. Hankin","code":""},{"path":"https://robinhankin.github.io/clifford/reference/zap.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Zap small values in a clifford object — zap","text":"","code":"a <- clifford(sapply(1:10,seq_len), 90^-(1:10)) zap(a) #> Element of a Clifford algebra, equal to #> + 0.01111111e_1 + 0.000123457e_12 + 1.372e-06e_123 + 1.5e-08e_1234 options(digits=3) zap(a) #> Element of a Clifford algebra, equal to #> + 0.0111e_1 + 0.00012e_12   a - zap(a)   # nonzero #> Element of a Clifford algebra, equal to #> + 1.11e-06e_1 + 3.46e-06e_12 + 1.37e-06e_123 + 1.52e-08e_1234 + 1.69e-10e_12345 #> + 1.88e-12e_123456 + 2.09e-14e_1234567 + 2.32e-16e_12345678 + #> 2.58e-18e_123456789 + 2.87e-20e_12345678910  B <- rblade(g=3) mB <- B*rev(B) zap(mB) #> [1] 47379 drop(mB) #> [1] 47379"},{"path":"https://robinhankin.github.io/clifford/reference/zero.html","id":null,"dir":"Reference","previous_headings":"","what":"The zero Clifford object — zero","title":"The zero Clifford object — zero","text":"Dealing zero Clifford object presents particular challenges.   methods need special dispensation zero object.","code":""},{"path":"https://robinhankin.github.io/clifford/reference/zero.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"The zero Clifford object — zero","text":"","code":"is.zero(x)"},{"path":"https://robinhankin.github.io/clifford/reference/zero.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"The zero Clifford object — zero","text":"x Clifford object","code":""},{"path":"https://robinhankin.github.io/clifford/reference/zero.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"The zero Clifford object — zero","text":"test Clifford object's zero, use .zero().   Idiom x==0 work irregardless, sometimes one   might prefer functional form stylistic reasons. create zero object ab initio, use clifford(list(),numeric(0)) although note scalar(0) work .","code":""},{"path":"https://robinhankin.github.io/clifford/reference/zero.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"The zero Clifford object — zero","text":"Robin K. S. Hankin","code":""},{"path":"https://robinhankin.github.io/clifford/reference/zero.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"The zero Clifford object — zero","text":"coefficient zero clifford object,   coeff(scalar(0)), numeric(0) (note 1 +     NULL also returns numeric(0)). Function .zero() problematic another package also   .zero() generic loaded, mask   clifford::.zero().  Specifically, jordan   package includes jordan::.zero() two play   nicely together.","code":""},{"path":[]},{"path":"https://robinhankin.github.io/clifford/reference/zero.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"The zero Clifford object — zero","text":"","code":"is.zero(rcliff()) #> [1] FALSE"},{"path":"https://robinhankin.github.io/clifford/news/index.html","id":"clifford-10-0","dir":"Changelog","previous_headings":"","what":"clifford 1.0-0","title":"clifford 1.0-0","text":"consistentification: use disordR","code":""}]
