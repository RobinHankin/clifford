---
title: "Dual numbers implemented using Clifford algebra, and a case-study of automatic differentiation"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library("clifford")
```

<p style="text-align: right;">
![](`r system.file("help/figures/clifford.png", package = "clifford")`){width=10%}
</p>


From wikipedia, dual numbers are expressions of the form
$a+b\epsilon$, with $a,b\in\mathcal{R}$ and $\epsilon^2=0$.  If we
define

$$\begin{eqnarray}
(a+b\epsilon) + (c+d\epsilon) &=& (a+c) + (b+d)\epsilon\\
(a+b\epsilon)(c+d\epsilon) &=& ac + (ad+bc)\epsilon
\end{eqnarray}$$


then we recover distributivity and associativity.  Actually
associativity of the product is not entirely trivial.  We seek to
prove $\left[(a+b\epsilon)(c+d\epsilon)\right](e+f\epsilon)=
(a+b\epsilon)\left[(c+d\epsilon)(e+f\epsilon)\right]$.

$$\begin{eqnarray}
LHS&=&\left[(a+b\epsilon)(c+d\epsilon)\right](e+f\epsilon)\\
&=&\left[ac+(ad+bc)\epsilon\right](e+f\epsilon)\\
&=& ace +  (acf+ade+bce)\epsilon\\[5mm]
RHS&=&(a+b\epsilon)\left[(c+d\epsilon)(e+f\epsilon)\right]\\
&=&(a+b\epsilon)\left[ce+(cf+de)\epsilon\right]\\
&=&ace + (acf+ade+bce)\epsilon\\
&=&RHS
\end{eqnarray}$$



The Clifford representation is easy, first setting the signature to
zero:

```{r}
library(clifford)
signature(0)
e(1)^2
```

Then, to calculate say $(3+4\epsilon)(5-6\epsilon)$:

```{r}
(3+4*e(1))*(5-6*e(1))
```

Numerical verification of algebraic identities is straightforward:

```{r}
rdual <- function(...){rnorm(1) + rnorm(1)*e(1)}
x <- rdual()
y <- rdual()
z <- rdual()
```

Then

```{r}
Mod(x*(y*z) - (x*y)*z)
Mod(x*(y+z) - (x*y+x*z))
Mod((x+y)*z - (x*z+y*z))
```

The above shows zero to within numerical tolerance.


## Automatic differentiation

*NOTE* This vignette shows a use-case for dual numbers, as applied to
 automatic differentiation.  If you want to actually use AD, I would
 strongly recommend you consider the excellent `dual` package which
 offers a nice user interface, efficient coding, and lots of examples.


First we define a simple polynomial:

```{r definasimplepoly}
f <- function(x){5*x + 3*x^5}
fdash <- function(f,x,d=1e-6){(f(x+d/2)-f(x-d/2))/d}
```

and observe that this can be evaluated at elements of a Clifford
algebra:

```{r, usef}
f(pi + e(1))
fdash(f,pi)
```

Above we see agreement.  This technique is limited by the fact that
only polynomial functionality is implemented in the Clifford package;
if we want to work with transcendental functions we need to supply the
derivative explictly:


```{r, label=mydefs}
getim <- function(x){x-const(x)}  # should be a builtin -- I'm working on it
my_sin <- function(x){sin(const(x)) + cos(const(x))*getim(x)}
my_cos <- function(x){cos(const(x)) - sin(const(x))*getim(x)}
```

Then to differentiate say $f_2(x)=\sin\left(\cos(x)+x^2\right)$:

```{r}
f2 <- function(x){sin(cos(x)+x^2)}
myf2 <- function(x){my_sin(my_cos(x)+x^2)}
myf2(pi + e(1))
fdash(f2,pi)
```


Above we see close agreement.  Observe that dual number formalism
tracks the differential via the $e_1$ term automatically; it
effectively uses the chain rule to differentiate.